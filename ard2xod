#!/usr/bin/env perl
# Make a XOD low-level library automatically from a Arduino IDE library
# --- command [options] $arduino-library-directory

use strict; use warnings; no warnings 'uninitialized'; use 5.012; no if ($^V ge v5.18.0), warnings => 'experimental::smartmatch';
use Carp; $SIG{__DIE__} = sub { Carp::confess @_ };
use Data::Dumper;
use File::Basename qw(basename dirname);
use JSON;
use Text::Template; # it was there

use lib 'bin';
use awgrover::Getopt;

my $gSwitches;

# BUG flags, turn off when fixed
our %BUG;
$BUG{'type_name_dash'} = 1; # the patch-name is supposed to be the custom type name, but the transpiler is not doing s/-/_/g;

my $XODRowSize = 102; # seems to be every 102 pixels
my $XODColSize = 34; # seems to be

# FIXME: hard code xod location
my $xoddir = "/home/".$ENV{'USER'}."/xod/__lib__"; # can we ask xod?
my $xodc = "/home/awgrover/dev/thirdparty/xod/xodc"; # installed xodc is broken, use built

# Types we know how to translate to xod
# (plus the "class" type of interest of course)
my %cpp2xod_type = (
  # we could handle * types with more info here:
  'TypeKind.INT:4' => 'xod/patch-nodes/input-number', # ints are bytes
  'TypeKind.INT:2' => 'xod/patch-nodes/input-number',
  'TypeKind.INT:1' => 'xod/patch-nodes/input-number',
  'TypeKind.BOOL:1' => 'xod/patch-nodes/input-boolean',
  'TypeKind.POINTER:8' => 'xod/patch-nodes/input-number', # pointers are bits # FIXME: this is actually a pointer to something
  'TypeKind.VOID:-2' => 'void', # special
  bool => 'xod/patch-nodes/input-boolean',
  );

# A .cpp for constructors looks like this:
my $cpp_constructor = <<'EOS'; # use {% ... %} interpolations
//-- constructor {% $arduino{'class_name'} %}({% our @args = map {$_->{'name'}} @{$constructor{'arguments'} }; join(", ", @args); %})
#pragma XOD require "{% $arduino{'github_url'} %}"

// Include C++ library:
{{#global}}
#include <{% $arduino{'.h'} %}>
{{/global}}

// Our namespace should be: {% $cpp{'cons_namespace'} %}
// Reserve the space for the object.
struct State {
  uint8_t mem[sizeof({% $arduino{'class_name'} %})];
  };
using Type = {% $arduino{'class_name'} %}*; // 'Type' is assumed by xod code-generator

{{ GENERATED_CODE }}

void evaluate(Context ctx) {
  // It should be evaluated only once on the first (setup) transaction
  if (!isSettingUp()) return; // FIXME: relax this?

  auto state = getState(ctx);

  // var names are valid c++ because we got them from the arglist of the c++ constructor
  {% 
  foreach my $arg ( @{$constructor{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}.">(ctx); // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  Type object = new (state->mem) {% $arduino{'class_name'} %}( {% join ", ", @args; %} );

  emitValue<output_{% $cpp{'cons_patch_name'} %}>(ctx, object);
  emitValue<output_done>(ctx, object);
}
EOS

my $cpp_method = <<'EOS';
//-- {% $method{'type'} %} {% $arduino{'class_name'} %}::{% $method{'name'} %}({% our @args = map {$_->{'name'}} @{$method{'arguments'} }; join(", ", @args); %})
// Our constructor namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  // only act on trigger, inputs not relevant for this
  if ( !isInputDirty<input_trigger>(ctx) ) return;

  // var names are valid c++ because we got them from the arglist of the c++ method
  {% 
  foreach my $arg ( @{$method{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}.">(ctx); // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  auto object  = getValue<input_{% $xod{'cons_patch_name'} %}>(ctx); // {% $arduino{'class_name'} %}

  {% ($method{'type'} ne 'void') ? 'auto rez = ' : '' %}object->{% $method{'name'} %}( {% join(", ", @args) %} ); // {%
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'void'
  %}
  
  emitValue<output_dev>(ctx, object); // for chaining

  {% if ($method{'type'} ne 'void') {
    'emitValue<output_val>(ctx, rez); // '.  $method{'type'};
    }
  else { 
    '';
    }
  %}
  emitValue<output_done>(ctx, 1); // pulse
}
EOS

my $cpp_static_method = <<'EOS';
//-- {% $method{'type'} %} {% $arduino{'class_name'} %}::{% $method{'name'} %}({% our @args = map {$_->{'name'}} @{$method{'arguments'} }; join(", ", @args); %})
// Our constructor namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  {% 
  if (@{$method{'arguments'}}) {
    $OUT .= "if (\n    ";

    our @dirty;
    push @dirty, "!isInputDirty<input_".$xod{'cons_patch_name'}.">(ctx)";
    foreach my $arg ( @$args ) {
      push @dirty, "!isInputDirty<input_".$arg->{'name'}.">(ctx)";
    } 
    $OUT .= join " &&\n    ",@dirty;
    $OUT .= "\n  ) return;";
    }
  else { '// no inputs' }
  %}

  // var names are valid c++ because we got them from the arglist of the c++ method
  {% 
  foreach my $arg ( @{$method{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}.">(ctx); // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  {% ($method{'type'} ne 'void') ? 'auto rez = ' : '' %}{% $arduino{'class_name'} %}::{% $method{'name'} %}( {% join(", ", @args) %} ); // {%
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'void'
  %}
  
  emitValue<output_{% $method{'type'} ne 'void' ? 'val' : 'done' %}>(ctx, {% $method{'type'} ne 'void' ? 'rez' : 1 %}); // {% 
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'pulse';
  %}
}
EOS

my $cpp_property = <<'EOS';
//-- {% $property{'type'} %} {% $arduino{'class_name'} %}::{% $property{'name'} %} getter/setter
// Our constructor namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  // Seems like an ugly pattern...

  // Set the value if incoming value is dirty (and emit it)
  if ( isInputDirty<input_val> ) {
    auto value  = getValue<input_val>(ctx); // {% $property{'type'} %}
    auto object  = getValue<input_{% $xod{'cons_patch_name'} %}>(ctx); // {% $arduino{'class_name'} %}
    object->{% $property{'name'} %} = value;

    emitValue<output_dev>(ctx, object);
    emitValue<output_out>(ctx, value);
    emitValue<output_done>(ctx, value);
  }

  // Emit the value if object is dirty ? or by pulse?
  else if ( isInputDirty<input_{% $xod{'cons_patch_name'} %}> ) {
    auto object  = getValue<input_{% $xod{'cons_patch_name'} %}>(ctx); // {% $arduino{'class_name'} %}
    auto value = object->{% $property{'name'} %};

    emitValue<output_dev>(ctx, object);
    emitValue<output_out>(ctx, value );
    emitValue<output_done>(ctx, value);
    }

  else {
    // not dirty, do nothing
    }

}
EOS

sub do_make {
  {
  local @ARGV = @ARGV;
  pop @ARGV;
  # FIXME: use the library name from this:
  do_library();
  }
  do_constructor();
  do_methods();
  do_static_methods();
  #do_properties(); # skip them
  do_specialize();
  }

sub ard_dot_h {
  my ($ard) = @_;
  # FIXME: could cache it
  my $fname = basename($ard) . ".h";
  my $path = "$ard/$fname";
  die "Expected the .h '$fname' in $ard" if (!-e $path);
  $path;
  }

sub ard_lib_property {
    # get the value from the .properties
    my ($ard, $property) = @_;
    state %properties;

    $properties{ $ard } ||= do {
        my %p;

        my $ph = IO::File->new($ard . "/library.properties", 'r') or die($!);
        while (<$ph>) {
            my ($key,$value) = /^([^=]+)=(.*)/;
            $p{$key} = $value;
            }
        \%p;
        };

    $properties{ $ard }->{$property};
    }

sub ard_lib_name {
    # from a directory and library_properties.author
    # -> good xod name
    my ($ard) = @_;
    
    # could cache
    my $lib_name = lc( ard_lib_property($ard,'author') . "/" . basename($ard) );
    $lib_name =~ s/_/-/g;
    $lib_name =~ s/[^0-9a-z\/-]//g;
    $lib_name;
    }

sub xodball2tmp {
  # xodball to unpacked tmp dir
  # check for sanity yourself
  my ($xodball) = @_;
  my $leaf = basename($xodball,'.xodball');

  my $path = "/tmp/xodball";
  # FIXME if lib, put in $author/$name
  $path .= "/".$leaf;

  $path;
  }

sub do_unpack {
  # --- $xodprojectdir # > /tmp/
  fail_with_help("Expected a .xodball",'unpack') if !@ARGV;

  foreach my $xod (@ARGV) {

    if (-d $xod || !-e $xod || (basename($xod) !~ /\.xodball$/) ) {
      say STDERR "# Expected a .xodball, but it's not: $xod";
      exit 1;
      }
    
    my $xodtmp = xodball2tmp( $xod );
    say "INTO $xodtmp";
    system('mkdir','-p', $xodtmp) and die;
    say( join " ", ($xodc,'unpack', $xod, $xodtmp."/x"));
    system($xodc,'unpack', $xod, $xodtmp."/x") and die;
    say "# unpacked: $xodtmp";
    }
  }

sub cpp_safe_token {
  my ($a) = @_;
  $a =~ s/-/_/g;
  die "bad token, can't cpp'ize it: '".$_[0]."'" if $a =~ /[^A-Za-z0-9_]/;
  $a
  }

sub foreach_method {
  my ($methods_ast, $block) = @_;
  my $ct = 0;
  say "Count of nodes: ".@$methods_ast;
  foreach my $method (@$methods_ast) {
    my $args_ast = find_all(0, $method, \&p_toplevel, p_node_type('PARM_DECL'));
    #say "  parms ",dump_shallow($_) foreach @$args_ast;

    my @inputs; # [ $name, $xodtypename, $actual-spelled-type ]
    my @saw; # for error message
    #say "  --- args...";
    foreach my $parm (@$args_ast) {
      my $input_name = $parm->{'text'};
      $input_name = cpp_safe_token($input_name);

      my $full_type = $parm->{'type'}; # unparsed, sad. "int *", "bool ()"
      push @saw, "$full_type $input_name";
      my ($base_type, @more_type_pieces) = split(" ",$full_type);

      my $cpp_type = $cpp2xod_type{$base_type};
      if (!$cpp_type) {
        my $sofar = join ", ", @saw;
        die "Don't know type for argument in method ".$method->{'text'}."($sofar,...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }
      my $type_name = $parm->{'type_name'};
      push @inputs, [ $input_name, $cpp_type, $type_name ];
      }

    #say "Inputs: ",Dumper(\@inputs);
    #say "method ".$method->{'text'}."(",join(", ", map {$_->[0]} @inputs),")";
    &$block( $ct, { name=> $method->{'text'}, type=>($method->{'return_type'} || $method->{'type'}), type_name=>$method->{'type_name'} }, \@inputs );

    $ct += 1;
    }
  $ct;
  }

sub do_ast {
  # just dump the ast
  # --- $ardlib
  my ($ard) = @ARGV;
  my $dot_h = ard_dot_h($ard);
  system("python", "./dump_ast.py", $dot_h);
  exit($?);
  }

sub do_properties {
  # Make public property patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;

  $gSwitches->{'limit'} = 5 if !$gSwitches->{'limit'};

  make_patches(
    'property',
    $ard, $xod,
    $cpp_property,
    # description_maker,
    sub {
      my ($defn, $property_node, $args, $ct) = @_;
      "property " . $property_node->{'text'}; # FIXME: use "doc" and comments etc
      },

    # xodp_maker,
    sub {
      my ($defn, $xodp, $property, $args, $ct) = @_;

      # each "row" of a patch
      my $xod_input_type = $cpp2xod_type{ $property->{'type'} };
      if (!$xod_input_type) {
        warn Dumper($property,);
        die "Don't know type for type of property ".$property->{'type'}." ".$property->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }
      add_nodes($xodp, 
        [ $defn->{'cpp'}->{'cons_patch_name'} => $defn->{'xod'}->{'input_type_name'} ],
        [ val => $xod_input_type ]
        );

      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      my $outtype = $xod_input_type; # same
      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      add_nodes($xodp, 
        [ out => $outtype],
        [ dev => $defn->{'xod'}->{'output_type_name'} ] 
        );
      },

    # template_data,
    sub {
      my ($defn, $property, $args) = @_;
      return { property => {
        name => $property->{'name'},
        type => $property->{'type_name'},
        }};
      },

    # ast preds
    [ p_node_type('FIELD_DECL'), p_access('PUBLIC') ],
    );
  }

sub definitions {
  # common values we need from $ard/$xod stuff
  # returns $ast (for first class), $defn
  my ($ard, $xod) = @_;

  my $libname;
  if ($xod =~ /\/__lib__\//) {
    $libname = ( basename(dirname($xod)) . "/" . basename($xod) );
    if ( $libname =~ /[^a-zA-Z0-9\/-]/ ) {
      die "xod dir for libraries must only use valid xod chars: [a-zA-Z0-9-], saw '$libname' from '$xod'" 
      }
    }

  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $dot_h = ard_dot_h($ard);
  if (!-d $ard || !-e $dot_h) {
    say STDERR "# Expected an arduino library xwith a .h in $ard";
    exit 1;
    }

  my $ast = `python ./dump_ast.py "$dot_h"`;
  exit(1) if $?;

  $ast = eval($ast);
  die $@ if $@;
 
  # We are always working on the first class...
  # FIXME: skip statics?
  my $class_ast = find_first(0, $ast, \&p_toplevel, p_node_type('CLASS_DECL'));
  die "No class" if !$class_ast;

  my %defn = (
    # values we need, categorized to reduce confusion
    # usable by the makers(), and the template
    arduino => {}, # strings from arduino world
    cpp => {}, # tokens that are for cpp
    xod => {}, # tokens that are for xod
    );
  $defn{'arduino'}->{'.h'} = basename($dot_h);
  $defn{'arduino'}->{'class_name'} = $class_ast->{'text'} or die("No {'text'} in the class node"); # WAS $class_name
  $defn{'arduino'}->{'github_url'} = $gSwitches->{'github-url'} || ard_lib_property($ard,'url');
  warn "The github url was in library.properties: ".ard_lib_property($ard,'url') if $gSwitches->{'github-url'} && ard_lib_property($ard,'url');

  $defn{'xod'}->{'cons_patch_name'} = lc( $defn{'arduino'}->{'class_name'} ); # base typename & patchname # WAS $cons_patch_name
  $defn{'xod'}->{'cons_patch_name'} =~ s/_/-/g; # xod wants -
  if ($BUG{'type_name_dash'} ) { $defn{'xod'}->{'cons_patch_name'} =~ s/-//g; }; # remove -
  
  my $type_base = $libname || '@'; # lib || project
  $defn{'xod'}->{'input_type_name'} = $type_base . "/input-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  $defn{'xod'}->{'output_type_name'} = $type_base . "/output-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  
  $defn{'cpp'}->{'cons_patch_name'} = $defn{'xod'}->{'cons_patch_name'}; # WAS cpp_patch_name
  $defn{'cpp'}->{'cons_patch_name'} =~ cpp_safe_token( $defn{'cpp'}->{'cons_patch_name'} ); # cpp wants _
  
  $defn{'cpp'}->{'cons_namespace'} = ard_lib_name($ard); # WAS namespace
  $defn{'cpp'}->{'cons_namespace'} =~ s/\//__/g; # lib path / -> __ for cpp
  $defn{'cpp'}->{'cons_namespace'} .= "__" . $defn{'cpp'}->{'cons_patch_name'};
  $defn{'cpp'}->{'cons_namespace'} = cpp_safe_token( $defn{'cpp'}->{'cons_namespace'} );
  #say "## defn: ",Dumper(\%defn);

  return ($class_ast, %defn);
  }

sub make_patches {
  # the factored code to generate patches from ast elements
  # fill in the various makers

  my ($what, $ard, $xod, $template, $description_maker, $xodp_maker, $template_data, $ast_predicates) = @_;
  
  my ($class_ast, %defn) = definitions( $ard, $xod );

  # What things are of interest to this patch maker? the @$ast_predicates
  my $methods_ast = find_all(0, $class_ast, @$ast_predicates);
  #print "found ${what}'s: ",dump_shallow($_),"\n" foreach @$methods_ast;
  if (!@$methods_ast) {
    warn "No ${what}'s";
    die;
    return;
    }


  my %method_counts = ();
  my $made_ct = foreach_method($methods_ast, sub {
    my ($ct, $method, $args) = @_;

    # append ct if not first one
    my $this_method_name = $method->{'name'};
    $this_method_name .= $method_counts{$this_method_name} if $method_counts{$this_method_name};

    #say "patch ($what) name: $this_method_name";
    say "  #args ",Dumper($args);

    my %xodp; # the .xodp structure for a constructor patch

    $xodp{'description'} = $description_maker ? $description_maker->(\%defn, $method, $args, $ct) : ""; # can we do better?
    #say "Description '",$xodp{'description'},"'";

    $xodp_maker->(\%defn, \%xodp, $method, $args, $ct);
    #say "Patch for $what: $this_method_name ",Dumper(\%xodp);

    # xodp_maker can provide name
    my $patch_name = delete $xodp{'patch_name'};
    if ($patch_name) {
      die "Patch name from the '$what' '$this_method_name' xodp_maker had non-xod chars in it [a-zA-Z-]: '$patch_name'" if $patch_name =~ /[^A-Za-z0-9-]/;
    } else {
      # fix patch name: dashify
      $patch_name = lcfirst($this_method_name);
      $patch_name =~ s/([A-Z])/'-'.lc($1)/eg;
      $patch_name =~ s/_-/-/g; # if there was _Cap
      #say "Dashified '$this_method_name' -> '$patch_name'";
      }
    if ($BUG{'type_name_dash'} && $method->{'node'} eq 'CONSTRUCTOR') {
      # type name == patch-name, but transpiler isn't doing global s/-/_/g;
      # so, drop -
      $patch_name =~ s/-//g;
      }

    #say "patch_name '$this_method_name' -> '$patch_name'";
    write_patch( "$xod/$patch_name/patch.xodp", \%xodp);
    
    #say "Method ",Dumper($method);
    # we assume the sub will modify/add only top-level keys
    my $new_data = $template_data->(\%defn, $method, $args, $ct);
    #say "new template data: ",Dumper($new_data);

    my %new_defn = (%defn, %$new_data);
    #say "template data: ",Dumper(\%new_defn);
    write_patch_cpp("$xod/$patch_name/patch.cpp", $template, \%new_defn);

    last if $gSwitches->{'limit'} && $gSwitches->{'limit'} < $ct+1;
    });
  say "Made ",$made_ct," $what patches";
  $made_ct;
  }

sub do_static_methods {
  # Make public static methods patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  my $made_ct = make_patches(
    'static method',
    $ard, $xod,
    $cpp_static_method,

    # description
    sub { my ($defn, $method_node, $args, $ct) = @_; # unused
        ''; # can we do better? comments? doc? line-number?
      },

    # %xodp
    sub { 
      my ($defn, $xodp, $method, $args, $ct) = @_;

      # each "row" of a patch

      # inputs
      add_nodes($xodp, 

        # the args
        @$args,
        );

      # cpp
      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # output node(s)
      my $outtype = $cpp2xod_type{ $method->{'type'} };
      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      if (!$outtype) {
        warn Dumper($method);
        die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }

      my @rez_nodes;

      if ($method->{'type'} eq 'TypeKind.VOID:-2') {
        push @rez_nodes, [ done => "xod/patch-nodes/output-pulse" ]; # pulse on finish
        }
      else {
        push @rez_nodes, [ val => $outtype ];
        }

      add_nodes($xodp, @rez_nodes );
      },

    # template-data
    sub {
      my ($defn, $method, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->{'github_url'};

      return { method => {
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC'), \&p_static ]
    );

  }

sub do_methods {
  # Make public methods patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  my $made_ct = make_patches(
    'method',
    $ard, $xod,
    $cpp_method,

    # description
    sub { my ($defn, $method_node, $args, $ct) = @_; # unused
        ''; # can we do better? comments? doc? line-number?
      },

    # %xodp
    sub { 
      my ($defn, $xodp, $method, $args, $ct) = @_;

      # each "row" of a patch

      # inputs
      add_nodes($xodp, 

        # the object
        [$defn->{'cpp'}->{'cons_patch_name'} => $defn->{'xod'}->{'input_type_name'}], 

        # the args
        @$args,

        # the pulse
        [ trigger => "xod/patch-nodes/input-pulse" ] # pulse for "do it"
        );

      # cpp
      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # output node(s)
      my $outtype = $cpp2xod_type{ $method->{'type'} };
      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      if (!$outtype) {
        warn Dumper($method);
        die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }

      my @rez_nodes;
      push @rez_nodes, [ dev => $defn->{'xod'}->{'output_type_name'}];

      if ($method->{'type'} ne 'TypeKind.VOID:-2') {
        push @rez_nodes, [ val => $outtype ];
        }

      push @rez_nodes, [ done => "xod/patch-nodes/output-pulse" ]; # pulse on finish

      add_nodes($xodp, @rez_nodes );
      },

    # template-data
    sub {
      my ($defn, $method, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->{'github_url'};

      return { method => {
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC'), \&p_instance ]
    );

  }

sub do_constructor {
  # Make a constructor patch
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  my $made_ct = make_patches(
    'constructor',
    $ard, $xod,
    $cpp_constructor,
    # description
    sub { my ($defn, $cons_node, $args, $ct) = @_; # unused
      # FIXME: also README?
      join "\n", (
        "constructor", # can we do better? comments? doc?
        $defn->{'arduino'}->{'github_url'},
        "Arduino: ".$defn->{'arduino'}->{'class_name'},
        "XOD: ".$defn->{'xod'}->{'input_type_name'},
        "cpp postfix: ".$defn->{'cpp'}->{'cons_patch_name'},
      );
      },
    # %xodp
    sub { 
      my ($defn, $xodp, $constructor_ast, $args, $ct) = @_;

      $xodp->{'patch_name'} = $defn->{'xod'}->{'cons_patch_name'} . ($ct==0 ? '' : $ct);

      add_nodes($xodp, @$args);

      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # the pulse
      my $pulse = [ done => "xod/patch-nodes/output-pulse" ]; # pulse for "done"

      if ($ct == 0) {
        # FIXME: description => 'arduino: $classname, xod: $typename, cpp: $typename'
        # self creates a type using patch-name
        # There's a bug: the deduced type-name in the cons code from output-self is actually the label name, not the patch name
        add_nodes($xodp, [$defn->{'cpp'}->{'cons_patch_name'} => 'xod/patch-nodes/output-self'], $pulse);
        }
      else {
        add_nodes($xodp, [ dev => $defn->{'xod'}->{'output_type_name'}], $pulse );
        }
      },

    # template-data
    sub {
      my ($defn, $constructor_ast, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->{'github_url'};

      return { constructor => {
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CONSTRUCTOR'), p_access('PUBLIC') ]
    );

  }

sub write_patch_cpp {
  my ($fname, $template_str, $data) = @_;

  #say "Data: ",Dumper($data);

  my $template = Text::Template->new(
    TYPE => 'STRING', 
    SOURCE => $template_str,
    DELIMITERS => ['{%', '%}']
    );

  my $cpp = $template->fill_in(HASH => $data);
  my $fh = IO::File->new( $fname, 'w') or die($!);
  print $fh $cpp;
  $fh->close;
  say "Wrote $fname";
  }

sub write_patch {
  my ( $fname, $xodp ) = @_;
  say "make patch $fname ...";
  system('mkdir','-p', dirname($fname) ) and die;
  my $xh = IO::File->new( $fname, 'w' ) or die($!);
  print $xh JSON->new->pretty->encode($xodp);
  $xh->close;
  }


sub add_nodes {
  my ($xodp, @inputs) = @_;
  # inputs are a list of [name => type] in order
  # This is one "row" of inputs, arranges these across
  # creates id, position

  #say "Update xodp ",Dumper($xodp);

  $xodp->{'nodes'} ||= [];
  my $nodes = $xodp->{'nodes'};

  my $row_y = (($nodes->[-1] || {})->{'position'} || {})->{'y'};
  $row_y = defined($row_y) ? $row_y + $XODRowSize : $XODRowSize; # start not in corner
  #say "Row ",$row_y/$XODRowSize;

  #say "inputs; ",Dumper(\@inputs);
  my $x = 2 * $XODColSize; # start not in corner
  my $in_ct = 0;
  foreach my $nt (@inputs) {
    my ($name,$type) = @$nt;

    # The id is "stable": if you generate a 2nd time, should be same id
    # this lets already existing patches continue to work
    # We might as well just use the label, since they are unique anyway
    my $id;
    if ($name) {
      # first letter of input/output
      $id .= substr( (split('/', $type))[-1], 0, 1 );
      $id .= "-";
      # the label
      $id .= $name;
      }
    elsif ( $type eq 'xod/patch-nodes/not-implemented-in-xod' ) {
      $id = 'cpp';
      }
    else {
      # what other ones don't have id?
      warn "Expected all un-named nodes to have an id, except xod/patch-nodes/not-implemented-in-xod. This was $type";
      $id = next_xod_id();
      }

    my %node;
    $node{'id'} = $id;
    $node{'label'} = $name if $name; # some nodes have no name, e.g. not-implemented-in-xod
    $node{'type'} = $type;
    $node{'position'} = { x => $x, y => $row_y };
    warn "# node ",$node{'label'}," [",$node{'id'},"] as ",$node{'type'};

    
    push @$nodes, \%node;

    $x += 2 * $XODColSize;
    $in_ct += 1;
    }
  }

sub next_xod_id {
  # 9 char id
  # start/end with alpha
  state $alpha = ['A'..'Z', 'a'..'z'];
  state $alphanum = [ @$alpha, '0'..'9','-' ];
  $alpha->[ rand( scalar @$alpha ) ] . (join "",map { $alphanum->[ rand( scalar @$alphanum ) ] } (1..7)) . $alpha->[ rand( scalar @$alpha ) ];
  }

sub p_toplevel {
  # if node is toplevel
  my ($depth, $node) =@_;
  $depth == 0;
  }

sub p_static {
  # static
  my ($depth, $node) =@_;
  $node->{'static'};
  }

sub p_instance {
  # not static
  my ($depth, $node) =@_;
  ! $node->{'static'};
  }

sub p_access {
  my ($access_type) = @_; # PUBLIC PROTECTED PRIVATE etc.
  die "Expected PUBLIC|PROTECTED|PRIVATE" if $access_type !~ /^PUBLIC|PROTECTED|PRIVATE$/;
  sub {
    my ($depth, $node) =@_;
    $node->{'access'} eq $access_type;
    }
  }

sub p_node_type {
  my ($type) = @_;
  sub {
    my ($depth, $node) =@_;
    $node->{'node'} eq $type;
    }
  }

sub dump_shallow {
  my ($node) = @_;
  local $Data::Dumper::Maxdepth=1;
  local $Data::Dumper::Indent=0;
  Dumper($node);
  }

sub find_first {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, 'first', @preds);
  }

sub find_all {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, undef, @preds);
  }

sub find {
  # find the first child node for and(....)
  my ($depth, $ast, $onfirst, @preds) = @_;
  #say "start ",dump_shallow($ast) if $depth==0;
  # say "  preds ",join(" ",@preds);

  my @found;
  foreach my $child ( @{ $ast->{'children'} || [] } ) {
    my $hit = 1;
    #say "  child: ",dump_shallow($child);
    foreach my $pred (@preds) {
      if (! &$pred( $depth, $child ) ) {
        $hit = 0;
        last;
        }
      }
    if ($hit) { 
      #say "  HIT ",dump_shallow($child);
      return $child if $onfirst; 
      push @found, $child;
      }
    else {
      #say "Nope $depth";
      }

    find($depth+1, $child, $onfirst, @preds);
    }
  \@found;
 }

sub do_library {
    # make the library bits
    # --- $ardlib # > $xoddir/$author/$arddir

    my $any;
    foreach my $ard (@ARGV) { 
      _do_library($ard);
      $any = 1;
      }
    fail_with_help("# Expected at least 1 arduino library", 'library') if !$any;
    }

sub _do_library {
    my ($ard) = @_;

    if (! -d $ard) {
        say STDERR "# Expected an Arduino library directory, but it's not a directory: $ard";
        exit 1;
        }

    # Dir
    my $subdir = "" . $xoddir;
    $subdir .= "/" . ard_lib_name($ard);
    system('mkdir','-p', $subdir) and die;
    say "made $subdir";

    # project.xod
    my %xod_project = (
        authors => [ grep {$_} (ard_lib_property($ard, 'author'), ard_lib_property($ard, 'maintainer')) ],
        name => ard_lib_property($ard,'name'),
        description => ard_lib_property($ard, 'sentence') . "\n" . ard_lib_property($ard, 'paragraph'),
        version => ard_lib_property($ard,'version'),
        );

    # FIXME: replace keys rather than overwriting all keys
    my $ph = IO::File->new("$subdir/project.xod",'w') or die($!);
    print $ph JSON->new->pretty->encode(\%xod_project);
    say "wrote $subdir/project.xod";

    }

sub do_specialize {
  # gate, if, and so on
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;

  my ($ast, %defn) = definitions( $ard, $xod );

  my $xod_builtin_lib = '/usr/lib/node_modules/xod-cli/__lib__';

  my @abstract_xodp_file = split "\n", `rgrep -l xod/patch-nodes/abstract $xod_builtin_lib --include '*.xodp'`;
  say "abs ",join(", ",@abstract_xodp_file);

  foreach my $an_abstract_xodp_file (@abstract_xodp_file) {
    my $patch_name = basename(dirname($an_abstract_xodp_file));
    say "Abstract patch $patch_name";

    my $this_patch_name = "$patch_name(".$defn{'cpp'}->{'cons_patch_name'}.")";

    my $xodp = specialize_xodp($xod, \%defn, $patch_name, $this_patch_name, $an_abstract_xodp_file);
    my $could = specialize_cpp($xod, $xod_builtin_lib, \%defn, $patch_name, $this_patch_name, $xodp, $an_abstract_xodp_file);

    if (!$could) {
      say "Couldn't do .cpp, so remove so far";
      system('rm', '-rf', "$xod/$this_patch_name");
      }
    }
  }

sub specialize_cpp {
  my ($xod, $xod_builtin_lib, $defn, $patch_name, $this_patch_name, $xodp, $an_abstract_xodp_file) = @_;
  my $extant_specialized_name = "$patch_name(number)/patch.cpp";
  say "From $extant_specialized_name ..";
  my $extant_specialized_file = `find $xod_builtin_lib -path '*/$extant_specialized_name'`;
  chomp $extant_specialized_file;
  if (!$extant_specialized_file) {
    warn "Can't find an exemplar for '$patch_name', like '*/$extant_specialized_name'\n";
    return 0;
    }

  say "From $extant_specialized_file ..";
  say "Wrote $xod/$this_patch_name/patch.cpp";
  my $rez = system('cp', $extant_specialized_file, "$xod/$this_patch_name/patch.cpp");

  return !$rez;
  }

sub specialize_xodp {
  my ($xod, $defn, $patch_name, $this_patch_name, $an_abstract_xodp_file) = @_;
  # makes the "specialized" nodes for things like if-then-else
  # by copying existing ones

  my $xodp = decode_json( `cat $an_abstract_xodp_file` );
  say "json: ",Dumper($xodp);

  # for un-labeled inputs, if only 1, then "IN", if more, then "IN1"..
  # so, we may have to fixup the first

  my ($firstin, $firstout); # {'node'}[n] entries
  my ($inct, $outct) = (1,1);
  foreach my $node (@{$xodp->{'nodes'}}) {
    # we'll implement it, so:
    if ($node->{'type'} eq 'xod/patch-nodes/abstract') {
      $node->{'type'} = 'xod/patch-nodes/not-implemented-in-xod';
      }
    # we do concrete types
    else {
      if ($node->{'type'} =~ /xod\/patch-nodes\/(input|output)-t([0-9])/) {
        my $in = $1 eq 'input';
        die "Don't know how to deal with $an_abstract_xodp_file, saw ".$node->{'type'}." for t>1" if ($2 ne '1');

        $node->{'type'} = $in ? $defn->{'xod'}->{'input_type_name'} : $defn->{'xod'}->{'output_type_name'};
        }
      if (!$node->{'label'}) {
        # unlabeled
        my $in = $node->{'type'} =~ /\/input-/;
        # remember for fixup
        if ($in) {
          if ($inct == 1) {
            $node->{'label'} = "IN";
            $firstin = $node 
            }
          else {
            $node->{'label'} = "IN$inct";
            }
          $inct += 1;
          }
        else {
          if ($outct == 1) {
            $node->{'label'} = "OUT";
            $firstout = $node 
            }
          else {
            $node->{'label'} = "OUT$outct";
            }
          $outct += 1;
          }
        }
      }
      say "  ".$node->{'label'}." => ".$node->{'type'};
    }
  # fixup firsts
  if ($inct > 2) {
    $firstin->{'label'} .= '1';
    say "  FIXUP in to ",$firstin->{'label'};
    }
  if ($outct > 2) {
    $firstout->{'label'} .= '1';
    say "  FIXUP out to ",$firstout->{'label'};
    }
  
  say "Abstract patch $this_patch_name";
  write_patch( "$xod/$this_patch_name/patch.xodp", $xodp);
  return $xodp;
  }

sub do_capture {
  my ($xod) = @ARGV;
  # we tend to build into $xoddir/__lib__
  # so, we should capture for this .git

  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $libname = basename($xod);
  my $author = basename(dirname($xod));
  system('rm','-rf', "xod/__lib__/$author/$libname") and die($!);
  system('cp', '-R', $xod, "xod/__lib__/$author") and die($!);
  say "# cp'd everything to xod/__lib__/$author/$libname";
  }

my %commands = (
    make => [
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the xod library',
        '--github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    # Parts
    library => [
        ''=>'--- ardlibdir # Make the xod library dir/properties',
        'help|h|H'=>'this',
        ],
    constructor => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the constructor nodes',
        '--github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    methods => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public method nodes',
        '--only:s' => 'only make this exact method name',
        '--limit:n' => 'only make this many methods',
        'help|h|H'=>'this',
        ],
    static_methods => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public static method nodes',
        '--only:s' => 'only make this exact method name',
        '--limit:n' => 'only make this many methods',
        'help|h|H'=>'this',
        ],
    specialize => [
        ''=>'--- ardlibdir xod-proj-dir # create specialization patches',
        '--limit:n' => 'only make this many properties',
        'help|h|H'=>'this',
        ],
    properties => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public property nodes',
        '--limit:n' => 'only make this many properties',
        'help|h|H'=>'this',
        ],
    capture => [
      '' => '--- xod-proj-dir' # copy into xod-dir __lib__
      ],
    # util
    ast => [ # --- ardlibdir
      '' => 'dump the ast',
      'help|h|H'=>'this',
      ],
    unpack => [
        ''=>'Unpack a .xodball into /tmp/xodball/* for further processing',
        'help|h|H'=>'this',
        ],
    );

sub fail_with_help {
    my ($msg, $command) = @_;
    say STDERR $msg;
    @ARGV = qw('--help');
    while(my ($c,$opdef) = each(%commands)) {
        say STDERR $c;
        awgrover::Getopt::xprintSwitchHelp(@$opdef);
        }
    exit 1;
    }

sub main {
    my $command = shift @ARGV;
    fail_with_help( "# Expected a command", undef ) if !defined($command);

    my $whichopts = $commands{$command};
    fail_with_help( "# Expected a command", undef ) if !defined($whichopts);

    $awgrover::Getopt::gUndefIfFail=1;
    $gSwitches = awgrover::Getopt::GetOptions( @$whichopts );
    exit(1) if !$gSwitches;

    no strict 'refs';
    &{"do_".$command}();
    use strict 'refs';
    }

main();
