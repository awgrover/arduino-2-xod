#!/usr/bin/env perl
# Make a XOD low-level library automatically from a Arduino IDE library
# --- command [options] $arduino-library-directory

use strict; use warnings; no warnings 'uninitialized'; use 5.012; no if ($^V ge v5.18.0), warnings => 'experimental::smartmatch';
use Carp; $SIG{__DIE__} = sub { Carp::confess @_ };
use Data::Dumper;
use File::Basename qw(basename dirname);
use JSON;
use Text::Template; # it was there

use lib 'bin';
use awgrover::Getopt;

# BUG flags, turn off when fixed
our %BUG;
$BUG{'type_name_dash'} = 1; # the patch-name is supposed to be the custom type name, but the transpiler is not doing s/-/_/g;

my $XODRowSize = 102; # seems to be every 102 pixels
my $XODColSize = 34; # seems to be

# FIXME: hard code xod location
my $xoddir = "/home/".$ENV{'USER'}."/xod/__lib__"; # can we ask xod?
my $xodc = "/home/awgrover/dev/thirdparty/xod/xodc"; # installed xodc is broken, use built

# Types we know how to translate to xod
# (plus the "class" type of interest of course)
my %cpp2xod_type = (
  # we could handle * types with more info here:
  'TypeKind.INT:4' => 'xod/patch-nodes/input-number', # ints are bytes
  'TypeKind.INT:2' => 'xod/patch-nodes/input-number',
  'TypeKind.INT:1' => 'xod/patch-nodes/input-number',
  'TypeKind.BOOL:1' => 'xod/patch-nodes/input-boolean',
  'TypeKind.POINTER:8' => 'xod/patch-nodes/input-number', # pointers are bits # FIXME: this is actually a pointer to something
  'TypeKind.VOID:-2' => 'void', # special
  bool => 'xod/patch-nodes/input-boolean',
  );

# A .cpp for constructors looks like this:
my $cpp_constructor = <<'EOS'; # use {% ... %} interpolations
//-- constructor {% $arduino{'class_name'} %}({% our @args = map {$_->{'name'}} @{$constructor{'arguments'} }; join(", ", @args); %})
#pragma XOD require "{% $arduino{'github_url'} %}"

// Include C++ library:
{{#global}}
#include <{% $arduino{'.h'} %}>
{{/global}}

// Our namespace should be: {% $cpp{'cons_namespace'} %}
// Reserve the space for the object.
struct State {
  uint8_t mem[sizeof({% $arduino{'class_name'} %})];
  };
using Type = {% $arduino{'class_name'} %}*; // 'Type' is assumed by xod code-generator

{{ GENERATED_CODE }}

void evaluate(Context ctx) {
  // It should be evaluated only once on the first (setup) transaction
  if (!isSettingUp()) return; // FIXME: relax this?

  auto state = getState(ctx);

  // var names are valid c++ because we got them from the arglist of the c++ constructor
  {% 
  foreach my $arg ( @{$constructor{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}.">; // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  Type object = new (state->mem) {% $arduino{'class_name'} %}( {% join ", ", @args; %} );

  emitValue<output_{% $cpp{'cons_patch_name'} %}>(ctx, object);
}
EOS

my $cpp_method = <<'EOS';
//-- {% $method{'type'} %} {% $arduino{'class_name'} %}::{% $method{'name'} %}({% our @args = map {$_->{'name'}} @{$constructor{'arguments'} }; join(", ", @args); %})
// Our namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  {% 
  if (@{$method{'arguments'}}) {
    $OUT .= "if (\n    ";

    our @dirty;
    push @dirty, "!isInputDirty<".$typename.">(ctx)";
    foreach my $arg ( @{$method{'arguments'} } ) {
      push @dirty, "!isInputDirty<".$arg->{'name'}.">(ctx)";
    } 
    $OUT .= join " &&\n    ",@dirty;
    $OUT .= "\n  ) return;";
    }
  else { '// no inputs' }
  %}

  // var names are valid c++ because we got them from the arglist of the c++ method
  {% 
  our @args;
  foreach my $arg ( @{$method{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}.">; // ".$arg->{'type_name'} ."\n  ";
    push @args, $arg->{'name'};
  } 
  %}

  auto object  = getValue<input_{% $typename %}>; // {% $arduino{'class_name'} %}

  {% ($method{'type'} ne 'void') ? 'auto rez = ' : '' %}object->{% $method{'name'} %}( {% join(", ", @args) %} ); // {%
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'void'
  %}
  
  emitValue<output_{% $typename %}>(ctx, object); // for chaining

  emitValue<output_{% $method{'type'} ne 'void' ? 'val' : 'done' %}>(ctx, {% $method{'type'} ne 'void' ? 'rez' : 1 %}); // {% 
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'pulse';
  %}
}
EOS

my $cpp_property = <<'EOS';
//-- {% $property{'type'} %} {% $arduino{'class_name'} %}::{% $property{'name'} %} getter/setter
// Our namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  // Seems like an ugly pattern...

  // Set the value if incoming value is dirty (and emit it)
  if ( isInputDirty<val> ) {
    auto value  = getValue<input_val>; // {% $property{'type'} %}
    auto object  = getValue<input_{% $typename %}>; // {% $arduino{'class_name'} %}
    object->{% $property{'name'} %} = value;
    emitValue<output_out>(ctx, value);
  }

  // Emit the value if object is dirty ? or by pulse?
  else if ( isInputDirty<{% $typename %}> ) {
    auto object  = getValue<input_{% $typename %}>; // {% $arduino{'class_name'} %}
    auto value = object->{% $property{'name'} %};

    emitValue<output_{% $typename %}>(ctx, object);
    emitValue<output_val>(ctx, value );
    }

  else {
    // not dirty, do nothing
    }

}
EOS

sub do_make {
  {
  say STDERR Dumper(\@ARGV);
  local @ARGV = @ARGV;
  pop @ARGV;
  say STDERR Dumper(\@ARGV);
  do_library();
  }
  do_constructor();
  do_methods();
  do_properties();
  }


my $gSwitches;

my %commands = (
    make => [
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the xod library',
        '--github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    # Parts
    library => [
        ''=>'--- ardlibdir # Make the xod library dir/properties',
        'help|h|H'=>'this',
        ],
    constructor => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the constructor nodes',
        '--github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    methods => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public method nodes',
        '--only:s' => 'only make this exact method name',
        '--limit:n' => 'only make this many methods',
        'help|h|H'=>'this',
        ],
    properties => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public property nodes',
        '--limit:n' => 'only make this many properties',
        'help|h|H'=>'this',
        ],
    # util
    ast => [ # --- ardlibdir
      '' => 'dump the ast',
      'help|h|H'=>'this',
      ],
    unpack => [
        ''=>'Unpack a .xodball into /tmp/xodball/* for further processing',
        'help|h|H'=>'this',
        ],
    );

sub fail_with_help {
    my ($msg, $command) = @_;
    say STDERR $msg;
    @ARGV = qw('--help');
    while(my ($c,$opdef) = each(%commands)) {
        say STDERR $c;
        awgrover::Getopt::xprintSwitchHelp(@$opdef);
        }
    exit 1;
    }

sub ard_dot_h {
  my ($ard) = @_;
  # FIXME: could cache it
  my $fname = basename($ard) . ".h";
  my $path = "$ard/$fname";
  die "Expected the .h '$fname' in $ard" if (!-e $path);
  $path;
  }

sub ard_lib_property {
    # get the value from the .properties
    my ($ard, $property) = @_;
    state %properties;

    $properties{ $ard } ||= do {
        my %p;

        my $ph = IO::File->new($ard . "/library.properties", 'r') or die($!);
        while (<$ph>) {
            my ($key,$value) = /^([^=]+)=(.*)/;
            $p{$key} = $value;
            }
        \%p;
        };

    $properties{ $ard }->{$property};
    }

sub ard_lib_name {
    # from a directory and library_properties.author
    # -> good xod name
    my ($ard) = @_;
    
    # could cache
    my $lib_name = lc( ard_lib_property($ard,'author') . "/" . basename($ard) );
    $lib_name =~ s/_/-/g;
    $lib_name =~ s/[^0-9a-z\/-]//g;
    $lib_name;
    }

sub xodball2tmp {
  # xodball to unpacked tmp dir
  # check for sanity yourself
  my ($xodball) = @_;
  my $leaf = basename($xodball,'.xodball');

  my $path = "/tmp/xodball";
  # FIXME if lib, put in $author/$name
  $path .= "/".$leaf;

  $path;
  }

sub do_unpack {
  # --- $xodprojectdir # > /tmp/
  fail_with_help("Expected a .xodball",'unpack') if !@ARGV;

  foreach my $xod (@ARGV) {

    if (-d $xod || !-e $xod || (basename($xod) !~ /\.xodball$/) ) {
      say STDERR "# Expected a .xodball, but it's not: $xod";
      exit 1;
      }
    
    my $xodtmp = xodball2tmp( $xod );
    say "INTO $xodtmp";
    system('mkdir','-p', $xodtmp) and die;
    say( join " ", ($xodc,'unpack', $xod, $xodtmp."/x"));
    system($xodc,'unpack', $xod, $xodtmp."/x") and die;
    say "# unpacked: $xodtmp";
    }
  }

sub cpp_safe_token {
  my ($a) = @_;
  $a =~ s/-/_/g;
  die "bad token, can't cpp'ize it: '".$_[0]."'" if $a =~ /[^A-Za-z0-9_]/;
  $a
  }

sub foreach_method {
  my ($methods_ast, $block) = @_;
  my $ct = 0;
  say "Count of nodes: ".@$methods_ast;
  foreach my $method (@$methods_ast) {
    my $args_ast = find_all(0, $method, \&p_toplevel, p_node_type('PARM_DECL'));
    #say "  parms ",dump_shallow($_) foreach @$args_ast;

    my @inputs; # [ $name, $xodtypename, $actual-spelled-type ]
    my @saw; # for error message
    #say "  --- args...";
    foreach my $parm (@$args_ast) {
      my $input_name = $parm->{'text'};
      $input_name = cpp_safe_token($input_name);

      my $full_type = $parm->{'type'}; # unparsed, sad. "int *", "bool ()"
      push @saw, "$full_type $input_name";
      my ($base_type, @more_type_pieces) = split(" ",$full_type);

      my $cpp_type = $cpp2xod_type{$base_type};
      if (!$cpp_type) {
        my $sofar = join ", ", @saw;
        die "Don't know type for argument in method ".$method->{'text'}."($sofar,...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }
      my $type_name = $parm->{'type_name'};
      push @inputs, [ $input_name, $cpp_type, $type_name ];
      }

    #say "Inputs: ",Dumper(\@inputs);
    say "method ".$method->{'text'}."(",join(", ", map {$_->[0]} @inputs),")";
    &$block( $ct, { name=> $method->{'text'}, type=>($method->{'return_type'} || $method->{'type'}), type_name=>$method->{'type_name'} }, \@inputs );

    $ct += 1;
    }
  $ct;
  }

sub do_ast {
  # just dump the ast
  # --- $ardlib
  my ($ard) = @ARGV;
  my $dot_h = ard_dot_h($ard);
  system("python", "./dump_ast.py", $dot_h);
  exit($?);
  }

sub do_properties {
  # Make public property patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;

  my $description_maker = sub {
    my ($property_node) = @_;
    "property " . $property_node->{'text'}; # FIXME: use "doc" and comments etc
    };

  my $xodp_maker = sub {
    my ($xodp, $property, $values) = @_;
    # cpp_patch_name => $cpp_patch_name, type_name_input => $type_name_input,

    # each "row" of a patch
    my $xod_input_type = $cpp2xod_type{ $property->{'type'} };
    add_nodes($xodp, 
      [ $values->{'cpp_patch_name'} => $values->{'type_name_input'} ],
      [ val => $xod_input_type ]
      );

    add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

    my $outtype = $cpp2xod_type{ $property->{'type'} };
    $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
    if (!$outtype) {
      warn Dumper($property,);
      die "Don't know type for type of property ".$property->{'type'}." ".$property->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
      }
    add_nodes($xodp, [ val => $outtype] );
    add_nodes($xodp, [$values->{'cons_patch_name'} => $values->{'type_name_output'} ] );
    };

  my $template_data = sub {
    my ($property, $data) = @_;
    $data->{'property'} = {
      name => $property->{'name'},
      type => $property->{'type_name'},
      }
    };

  make_patches(
    'property',
    $ard, $xod,
    $cpp_property,
    $description_maker,
    $xodp_maker,
    $template_data,
    [ p_node_type('FIELD_DECL'), p_access('PROTECTED') ],
    );
  }

sub make_patches {
  # the factored code to generate patches
  # fill in the various makers

  my ($what, $ard, $xod, $template, $description_maker, $xodp_maker, $template_data, $ast_predicates) = @_;
  
  my $libname;
  if ($xod =~ /\/__lib__\//) {
    $libname = ( basename(dirname($xod)) . "/" . basename($xod) );
    if ( $libname =~ /[^a-zA-Z0-9\/-]/ ) {
      die "xod dir for libraries must only use valid xod chars: [a-zA-Z0-9-], saw '$libname' from '$xod'" 
      }
    }

  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $dot_h = ard_dot_h($ard);
  if (!-d $ard || !-e $dot_h) {
    say STDERR "# Expected an arduino library xwith a .h in $ard";
    exit 1;
    }

  my $ast = `python ./dump_ast.py "$dot_h"`;
  exit(1) if $?;

  $ast = eval($ast);
  die $@ if $@;
 
  # We are always working on the first class...
  # FIXME: skip statics?
  my $class_ast = find_first(0, $ast, \&p_toplevel, p_node_type('CLASS_DECL'));
  die "No class" if !$class_ast;

  # What things are of interest to this patch maker? the @$ast_predicates
  my $methods_ast = find_all(0, $class_ast, @$ast_predicates);
  #print "found ${what}'s: ",dump_shallow($_),"\n" foreach @$methods_ast;
  if (!@$methods_ast) {
    warn "No ${what}'s";
    return;
    }

  my %defn = (
    # values we need, categorized to reduce confusion
    # usable by the makers(), and the template
    arduino => {}, # strings from arduino world
    cpp => {}, # tokens that are for cpp
    xod => {}, # tokens that are for xod
    );
  $defn{'arduino'}->{'.h'} = basename($dot_h);
  $defn{'arduino'}->{'class_name'} = $class_ast->{'text'} or die("No {'text'} in the class node"); # WAS $class_name
  $defn{'arduino'}->{'github_url'} = $gSwitches->{'github-url'} || ard_lib_property($ard,'url');
  warn "The github url was in library.properties: ".ard_lib_property($ard,'url') if $gSwitches->{'github-url'} && ard_lib_property($ard,'url');

  $defn{'xod'}->{'cons_patch_name'} = lc( $defn{'arduino'}->{'class_name'} ); # base typename & patchname # WAS $cons_patch_name
  $defn{'xod'}->{'cons_patch_name'} =~ s/_/-/g; # xod wants -
  if ($BUG{'type_name_dash'} ) { $defn{'xod'}->{'cons_patch_name'} =~ s/-//g; }; # remove -
  
  my $type_base = $libname || '@'; # lib || project
  $defn{'xod'}->{'input_type_name'} = $type_base . "/input-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  $defn{'xod'}->{'output_type_name'} = $type_base . "/output-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  
  $defn{'cpp'}->{'cons_patch_name'} = $defn{'xod'}->{'cons_patch_name'}; # WAS cpp_patch_name
  $defn{'cpp'}->{'cons_patch_name'} =~ cpp_safe_token( $defn{'cpp'}->{'cons_patch_name'} ); # cpp wants _
  
  $defn{'cpp'}->{'cons_namespace'} = ard_lib_name($ard); # WAS namespace
  $defn{'cpp'}->{'cons_namespace'} =~ s/\//__/g; # lib path / -> __ for cpp
  $defn{'cpp'}->{'cons_namespace'} .= "__" . $defn{'cpp'}->{'cons_patch_name'};
  $defn{'cpp'}->{'cons_namespace'} = cpp_safe_token( $defn{'cpp'}->{'cons_namespace'} );
  say "## defn: ",Dumper(\%defn);

  my %method_counts = ();
  my $made_ct = foreach_method($methods_ast, sub {
    my ($ct, $method, $args) = @_;

    # append ct if not first one
    my $this_method_name = $method->{'name'};
    $this_method_name .= $method_counts{$this_method_name} if $method_counts{$this_method_name};

    say "patch ($what) name: $this_method_name";
    #say "  #args ",Dumper($args);

    my %xodp; # the .xodp structure for a constructor patch

    $xodp{'description'} = $description_maker ? $description_maker->(\%defn, $method, $args, $ct) : ""; # can we do better?
    say "Description '",$xodp{'description'},"'";

    $xodp_maker->(\%defn, \%xodp, $method, $args, $ct);
    say "Patch for $what: $this_method_name ",Dumper(\%xodp);

    # xodp_maker can provide name
    my $patch_name = delete $xodp{'patch_name'};
    if ($patch_name) {
      die "Patch name from the '$what' '$this_method_name' xodp_maker had non-xod chars in it [a-zA-Z-]: '$patch_name'" if $patch_name =~ /[^A-Za-z0-9-]/;
    } else {
      # fix patch name: dashify
      $patch_name = lcfirst($this_method_name);
      $patch_name =~ s/([A-Z])/'-'.lc($1)/eg;
      $patch_name =~ s/_-/-/g; # if there was _Cap
      say "Dashified '$this_method_name' -> '$patch_name'";
      }
    if ($BUG{'type_name_dash'} && $method->{'node'} eq 'CONSTRUCTOR') {
      # type name == patch-name, but transpiler isn't doing global s/-/_/g;
      # so, drop -
      $patch_name =~ s/-//g;
      }

    say "patch_name '$this_method_name' -> '$patch_name'";
    write_patch( "$xod/$patch_name/patch.xodp", \%xodp);
    
    #say "Method ",Dumper($method);
    # we assume the sub will modify/add only top-level keys
    my $new_data = $template_data->(\%defn, $method, $args, $ct);
    say "new template data: ",Dumper($new_data);

    my %new_defn = (%defn, %$new_data);
    say "template data: ",Dumper(\%new_defn);
    write_patch_cpp("$xod/$patch_name/patch.cpp", $template, \%new_defn);

    $ct += 1;
    last if $gSwitches->{'limit'} && $gSwitches->{'limit'} < $ct+1;
    });
  say "Made ",$made_ct+1," $what patches";
  }

sub do_methods {
  # Make public methods patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  my $methods_ast = find_all(0, $class_ast, \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC') );
  #print "methods ",dump_shallow($_),"\n" foreach @$methods_ast;
  if (!@$methods_ast) {
    warn "No methods";
    return;
    }

  my $cons_patch_name = $class_ast->{'text'} or die("No {'text'} in the class node");
  die "Don't know how to make xod project name safely from '$cons_patch_name'" if $cons_patch_name =~ /[^A-Z0-9a-z_]/;
  my $class_name = $cons_patch_name;
  $cons_patch_name = lc $cons_patch_name; # for xod stuff
  my $cpp_patch_name = $cons_patch_name; # we want _
  $cons_patch_name =~ s/_/-/g; # name wants -

  my $type_base = $xod =~ /\/__lib__\// ? ( basename(dirname($xod)) . "/" . basename($xod) ) : '@';
  my $type_name_output = $type_base . "/output-" . $cons_patch_name; # xod bug? should be: $cons_patch_name;
  my $type_name_input = $type_base . "/input-" . $cons_patch_name; # xod bug? should be: $cons_patch_name;
  
  my %method_counts = ();
  my $made_ct = foreach_method($methods_ast, sub {
    my ($ct, $method, $args) = @_;

    # append ct if not first one
    my $this_method_name = $method->{'name'};
    $this_method_name .= $method_counts{$this_method_name} if $method_counts{$this_method_name};
    next if $gSwitches->{'only'} && $gSwitches->{'only'} ne $this_method_name;

    #say "method patch name: $this_method_name";
    #say "  #args ",Dumper($args);

    my %xodp; # the .xodp structure for a constructor patch
    $xodp{'description'} = ""; # can we do better?

    # each "row" of a patch
    add_nodes(\%xodp, [$cpp_patch_name => $type_name_input], @$args);
    add_nodes(\%xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

    my $outtype = $cpp2xod_type{ $method->{'type'} };
    $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
    if (!$outtype) {
      warn Dumper($method);
      die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
      }

    my @rez_nodes;
    push @rez_nodes, [$cons_patch_name => $type_name_output];
    if ($method->{'type'} eq 'TypeKind.VOID:-2') {
      push @rez_nodes, [ done => "xod/patch-nodes/output-pulse" ]; # pulse on finish
      }
    else {
      push @rez_nodes, [ val => $outtype ]; # pulse on finish
      }
    add_nodes(\%xodp, @rez_nodes );


    #say "Patch ",Dumper(\%xodp);
    # fix patch name
    my $patch_name = lcfirst($this_method_name);
    $patch_name =~ s/([A-Z])/'-'.lc($1)/eg;
    write_patch( "$xod/$patch_name/patch.xodp", \%xodp);
    
    my $namespace = ard_lib_name($ard) . "__" . $cpp_patch_name;
    $namespace =~ s/\//__/g;
    $namespace = cpp_safe_token($namespace);
    
    #say "Method ",Dumper($method);
    my %data = (
      arduino => {
        '.h' => basename($dot_h),
        classname => $class_name,
        },
      method => {
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        },
      namespace => $namespace,
      typename => $cpp_patch_name,
      );
    write_patch_cpp("$xod/$patch_name/patch.cpp", $cpp_method, \%data);

    $ct += 1;
    #say "#---end method generation";
    last if $gSwitches->{'only'};
    last if $gSwitches->{'limit'} && $gSwitches->{'limit'} < $ct+1;
    });
  say "Made ",$made_ct+1," method patches";
  }

sub do_constructor {
  # Make a constructor patch
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  my $made_ct = make_patches(
    'constructor',
    $ard, $xod,
    $cpp_constructor,
    # description
    sub { my ($defn, $cons_node, $args, $ct) = @_; # unused
      # FIXME: also README?
      join "\n", (
        "constructor", # can we do better? comments? doc?
        $defn->{'arduino'}->{'github_url'},
        "Arduino: ".$defn->{'arduino'}->{'class_name'},
        "XOD: ".$defn->{'xod'}->{'input_type_name'},
        "cpp postfix: ".$defn->{'cpp'}->{'cons_patch_name'},
      );
      },
    # %xodp
    sub { 
      my ($defn, $xodp, $constructor_ast, $args, $ct) = @_;

      $xodp->{'patch_name'} = $defn->{'xod'}->{'cons_patch_name'} . ($ct==0 ? '' : $ct);

      add_nodes($xodp, @$args);

      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      if ($ct == 0) {
        # FIXME: description => 'arduino: $classname, xod: $typename, cpp: $typename'
        # self creates a type using patch-name
        # There's a bug: the deduced type-name in the cons code from output-self is actually the label name, not the patch name
        add_nodes($xodp, [$defn->{'cpp'}->{'cons_patch_name'} => 'xod/patch-nodes/output-self']);
        }
      else {
        add_nodes($xodp, [$defn->{'cpp'}->{'cons_patch_name'} => $defn->{'xod'}->{'output_type_name'}] );
        }
      },

    # template-data
    sub {
      my ($defn, $constructor_ast, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->{'github_url'};

      return { constructor => {
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CONSTRUCTOR'), p_access('PUBLIC') ]
    );

  say "Made ",$made_ct+1," constructor patches";
  }

sub write_patch_cpp {
  my ($fname, $template_str, $data) = @_;

  say "Data: ",$data->{'constructor'}->{'arguments'},' : ',Dumper($data->{'constructor'}->{'arguments'});

  my $template = Text::Template->new(
    TYPE => 'STRING', 
    SOURCE => $template_str,
    DELIMITERS => ['{%', '%}']
    );

  my $cpp = $template->fill_in(HASH => $data);
  my $fh = IO::File->new( $fname, 'w') or die($!);
  print $fh $cpp;
  $fh->close;
  say "Wrote $fname";
  }

sub write_patch {
  my ( $fname, $xodp ) = @_;
  say "make patch $fname...";
  system('mkdir','-p', dirname($fname) ) and die;
  my $xh = IO::File->new( $fname, 'w' ) or die($!);
  print $xh JSON->new->pretty->encode($xodp);
  $xh->close;
  }


sub add_nodes {
  my ($xodp, @inputs) = @_;
  # inputs are a list of [name => type] in order
  # This is one "row" of inputs, arranges these across
  # creates id, position

  #say "Update xodp ",Dumper($xodp);

  $xodp->{'nodes'} ||= [];
  my $nodes = $xodp->{'nodes'};

  my $row_y = (($nodes->[-1] || {})->{'position'} || {})->{'y'};
  $row_y = defined($row_y) ? $row_y + $XODRowSize : $XODRowSize; # start not in corner
  #say "Row ",$row_y/$XODRowSize;

  #say "inputs; ",Dumper(\@inputs);
  my $x = 2 * $XODColSize; # start not in corner
  my $in_ct = 0;
  foreach my $nt (@inputs) {
    my ($name,$type) = @$nt;

    my %node;
    $node{'id'} = next_xod_id();
    $node{'label'} = $name if $name; # some nodes have no name, e.g. not-implemented-in-xod
    $node{'type'} = $type;
    $node{'position'} = { x => $x, y => $row_y };

    
    push @$nodes, \%node;

    $x += 2 * $XODColSize;
    $in_ct += 1;
    }
  }

sub next_xod_id {
  # 9 char id
  # start/end with alpha
  state $alpha = ['A'..'Z', 'a'..'z'];
  state $alphanum = [ @$alpha, '0'..'9','-' ];
  $alpha->[ rand( scalar @$alpha ) ] . (join "",map { $alphanum->[ rand( scalar @$alphanum ) ] } (1..7)) . $alpha->[ rand( scalar @$alpha ) ];
  }

sub p_toplevel {
  # if node is toplevel
  my ($depth, $node) =@_;
  $depth == 0;
  }

sub p_access {
  my ($access_type) = @_; # PUBLIC PROTECTED PRIVATE etc.
  die "Expected PUBLIC|PROTECTED|PRIVATE" if $access_type !~ /^PUBLIC|PROTECTED|PRIVATE$/;
  sub {
    my ($depth, $node) =@_;
    $node->{'access'} eq $access_type;
    }
  }

sub p_node_type {
  my ($type) = @_;
  sub {
    my ($depth, $node) =@_;
    $node->{'node'} eq $type;
    }
  }

sub dump_shallow {
  my ($node) = @_;
  local $Data::Dumper::Maxdepth=1;
  local $Data::Dumper::Indent=0;
  Dumper($node);
  }

sub find_first {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, 'first', @preds);
  }

sub find_all {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, undef, @preds);
  }

sub find {
  # find the first child node for and(....)
  my ($depth, $ast, $onfirst, @preds) = @_;
  #say "start ",dump_shallow($ast) if $depth==0;
  # say "  preds ",join(" ",@preds);

  my @found;
  foreach my $child ( @{ $ast->{'children'} || [] } ) {
    my $hit = 1;
    #say "  child: ",dump_shallow($child);
    foreach my $pred (@preds) {
      if (! &$pred( $depth, $child ) ) {
        $hit = 0;
        last;
        }
      }
    if ($hit) { 
      #say "  HIT ",dump_shallow($child);
      return $child if $onfirst; 
      push @found, $child;
      }
    else {
      #say "Nope $depth";
      }

    find($depth+1, $child, $onfirst, @preds);
    }
  \@found;
 }

sub do_library {
    # make the library bits
    # --- $ardlib # > $xoddir/$author/$arddir

    my $any;
    foreach my $ard (@ARGV) { 
      _do_library($ard);
      $any = 1;
      }
    fail_with_help("# Expected at least 1 arduino library", 'library') if !$any;
    }

sub _do_library {
    my ($ard) = @_;

    if (! -d $ard) {
        say STDERR "# Expected an Arduino library directory, but it's not a directory: $ard";
        exit 1;
        }

    # Dir
    my $subdir = "" . $xoddir;
    $subdir .= "/" . ard_lib_name($ard);
    system('mkdir','-p', $subdir) and die;
    say "made $subdir";

    # project.xod
    my %xod_project = (
        authors => [ grep {$_} (ard_lib_property($ard, 'author'), ard_lib_property($ard, 'maintainer')) ],
        name => ard_lib_property($ard,'name'),
        description => ard_lib_property($ard, 'sentence') . "\n" . ard_lib_property($ard, 'paragraph'),
        version => ard_lib_property($ard,'version'),
        );

    # FIXME: replace keys rather than overwriting all keys
    my $ph = IO::File->new("$subdir/project.xod",'w') or die($!);
    print $ph JSON->new->pretty->encode(\%xod_project);
    say "wrote $subdir/project.xod";

    }

sub main {
    my $command = shift @ARGV;
    fail_with_help( "# Expected a command", undef ) if !defined($command);

    my $whichopts = $commands{$command};
    fail_with_help( "# Expected a command", undef ) if !defined($whichopts);

    $awgrover::Getopt::gUndefIfFail=1;
    $gSwitches = awgrover::Getopt::GetOptions( @$whichopts );
    exit(1) if !$gSwitches;

    no strict 'refs';
    &{"do_".$command}();
    use strict 'refs';
    }

main();
