#!/usr/bin/env perl
# Make a XOD low-level library automatically from a Arduino IDE library
# --- command [options] $arduino-library-directory

use strict; use warnings; no warnings 'uninitialized'; use 5.012; no if ($^V ge v5.18.0), warnings => 'experimental::smartmatch';
use Carp; $SIG{__DIE__} = sub { Carp::confess @_ };
use Data::Dumper;
use File::Basename qw(basename dirname);
use JSON;
use Template;

use lib 'bin';
use awgrover::Getopt;

our $VERSION = 'v1.1.0';
# 1.1.0 first numbered version. Template::Toolkit, name collision
# 1.0.0 10% less shitty: finds paths, config file, etc.

my $gSwitches;
my @warnings; # accumulate warnings for readme

# BUG flags, turn off when fixed
our %BUG;
$BUG{'type_name_dash'} = 1; # the patch-name is supposed to be the custom type name, but the transpiler is not doing s/-/_/g;

my $XODRowSize = 102; # seems to be every 102 pixels
my $XODColSize = 34; # seems to be

# variables used in the body of methods/constructor, to detect argument collisions
my @ReservedVariableNames = qw(_object dev trigger _state done _rez);

sub debug {
  if ($ENV{'DEBUG'}) {
    # & or msg,msg,msg
    my $from = (caller(0))[2];
    say ("[$from] ",(ref($_[0]) eq 'CODE') ? $_[0]->() : join(" ",@_));
    }
  }

package Arduino;
use Class::MethodMaker 
    [ 
    new => [ qw( -hash new )],
    scalar => [ 
      'dir',  # root directory of arduino library
      'known_dot_h', # override the assumption of library.properties['name'].h
      'known_github_url', # override the assumption of library.properties
      '_dot_h', # cached location
      '_dot_h_ast', # cached ast
      '_class_ast', # cached ast of the class
      '_github_url', # cached
      '_lib_property', # cached library.properties
      ],
    ];

  #use overload fallback => 1, '""' => sub { "<arduino ".$_[0]->dir.">" };

  use File::Basename qw(basename dirname);
  use JSON;

  sub expected {
    # a complete arduino library directory?
    my $self=shift;

    if (!-d $self->dir ) {
      say STDERR "# Expected an arduino library with a .h in @{[$self->dir]}";
      exit 1;
      }

    $self->dot_h; # checks
    }

  sub dot_h_basename {
    my $self=shift;
    basename( $self->dot_h );
    }

  sub dot_h {
    my $self = shift;
    # Often it's the $directory.h
    # or the library.properties['name'] .h
    # But, you may need to --dot-h $something
    # caches

    return $self->_dot_h if $self->_dot_h;

    my @candidates;

    if ($self->known_dot_h) {
      push @candidates, $self->known_dot_h;
      }

    else {
      # the directory name is often the .h name
      push @candidates, basename($self->dir) . ".h";

      if (-e $self->dir."/library.properties") {
        push @candidates, $self->lib_property('name'). ".h";
        }
      }
    
    foreach my $fname (@candidates) {
      my $path = $self->dir."/$fname";

      if (! -e $path && -d $self->dir."/src") {
        # maybe src/...
        $path = $self->dir."/src/$fname";
        }
      $self->_dot_h( $path );
      return $path if -e $path
      }

    die "Expected the .h in ".$self->dir." or ".$self->dir."/src, for '".join("', '",@candidates)."'";
    }

  sub dot_h_ast {
    my $self=shift;
    return $self->_dot_h_ast if $self->_dot_h_ast;

    my $ast = `python ./dump_ast.py "@{[$self->dot_h]}"`;
    exit(1) if $?;
    $self->_dot_h_ast( decode_json($ast) );
    die $@ if $@;
    $self->_dot_h_ast;
    }

  sub class_ast {
    my $self=shift;

    return $self->_class_ast if $self->_class_ast;

    # We are always working on the first class...
    $self->_class_ast( ::find_first(0, $self->dot_h_ast, \&::p_toplevel, ::p_node_type('CLASS_DECL')) );
    die "No class" if !$self->_class_ast;

    $self->_class_ast;
    }

  sub class_name {
    my $self=shift;
    $self->class_ast->{'text'} or die("No {'text'} in the class node");
    }

  sub github_url {
    my $self=shift;
    return $self->_github_url if $self->_github_url;

    my $rez = $self->known_github_url || $self->lib_property('github-url');

    warn "The github url was in library.properties: ".$self->lib_property('github-url') if !$self->known_github_url && $rez;
    $self->_github_url( $rez );
    }

  sub lib_property {
    # get the value from the library.properties & library.json
    # Treats library.json as secondard information, merges
    # Has a few magic keys
    my $self=shift;

    my ($property) = @_;

    my $cached ||= do {
        my %p;

        if (-e "@{[$self->dir]}/library.json") {
          # let library.properties overwrite later
          %p =  %{ decode_json( `cat @{[$self->dir]}/library.json` ) };
          }

        my $ph = IO::File->new( "@{[$self->dir]}/library.properties", 'r') or die($!);
        while (<$ph>) {
            my ($key,$value) = /^([^=]+)=(.*)/;
            $p{$key} = $value;
            }
        \%p;
        };
    $self->_lib_property($cached);

    # magic keys
    given ($property) {
      when ('github-url') {
        my $u = $self->_lib_property->{'repository'}->{'url'};
        if ($u) {
          $u =~ s/\.git$//; # trailing .git
          }
        else {
          $u = $self->_lib_property->{'url'}; # defined as "website" so may not be git
          }
        if ($u !~ /\/\/github.com\//) {
          die "The github-url from library.json['respository']['url'] || library.properties['url'] is not on github, and won't work with XOD version ~0.25, use --github-url";
          }
        $u;
        }
      default {
        $self->_lib_property->{$property};
        }
      }

    }

### end Arduino class

package main;

sub xod_projects {
  # find the directory that contains the XOD projects
  # FIXME: is it always true: $xod_projects/__lib__ is the xod libraries?
  state $xod_projects;
  return $xod_projects if $xod_projects;

  $xod_projects = config()->{'path'}->{'xod_projects'};
  return if $xod_projects;

  # FIXME: xodc should tell us this
  given ($^O) { # $OSNAME
    when ('linux') {
      # at least for ubuntu ~16.04:
      $xod_projects = "/home/".$ENV{'USER'}."/xod";
      }
    default {
      die "Sadly, this script doesn't know how to find the XOD projects directory on '$^O'\nSet .config path=>xod_projects=>'/some/thing' for now, and submit the solution to https://github.com/awgrover/arduino-2-xod/issues";
      }
    }

  return $xod_projects;
  }

sub xod_libraries {
  # find the directory that contains the XOD libraries
  # FIXME: have config() do all of this, then we can query our "environment" to see what we found
  state $xod_libraries;
  return $xod_libraries if $xod_libraries;

  $xod_libraries = config()->{'path'}->{'xod_library'};
  return if $xod_libraries;

  # FIXME: xodc should tell us this
  given ($^O) { # $OSNAME
    when ('linux') {
      # at least for ubuntu ~16.04:
      $xod_libraries = "/home/".$ENV{'USER'}."/xod/__lib__";
      }
    default {
      die "Sadly, this script doesn't know how to find the XOD libraries directory on '$^O'\nSet .config path=>xod_library=>'/some/thing' for now, and submit the solution to https://github.com/awgrover/arduino-2-xod/issues";
      }
    }

  return $xod_libraries;
  }

sub xodc {
  # find the xodc tool: config->`which`->`locate`
  state $xodc;
  return $xodc if $xodc;

  $xodc = config()->{'path'}->{'xodc'};
  if (!$xodc) {
    $xodc = `which xodc`;
    chomp $xodc;
    }
  if (!$xodc) {
    $xodc = `whereis xodc`;
    chomp $xodc;
    $xodc =~ /: /; # nm: /path/to/it
    $xodc = $';
    }
  if (!$xodc) {
    die "Can't find xodc, add to .config as bin=>xodc=>\"/path/to/it\"";
    }

  return $xodc;
  }

# Types we know how to translate to xod
# (plus the "class" type of interest of course)
my %cpp2xod_type = (
  # we could handle * types with more info here:
  'TypeKind.INT:4' => 'xod/patch-nodes/input-number', # ints are bytes
  'TypeKind.UINT:4' => 'xod/patch-nodes/input-number', # ints are bytes
  'TypeKind.INT:2' => 'xod/patch-nodes/input-number',
  'TypeKind.INT:1' => 'xod/patch-nodes/input-number',
  'TypeKind.USHORT:2' => 'xod/patch-nodes/input-number', 
  'TypeKind.UCHAR:1' => 'xod/patch-nodes/input-byte', 
  'TypeKind.CHAR_S:1' => 'xod/patch-nodes/input-byte',  
  'TypeKind.LONG:8' => 'xod/patch-nodes/input-number', 
  'TypeKind.ULONG:8' => 'xod/patch-nodes/input-number', 
  'TypeKind.DOUBLE:8' => 'xod/patch-nodes/input-number', 
  'TypeKind.BOOL:1' => 'xod/patch-nodes/input-boolean',
  'TypeKind.ENUM:4' => 'xod/patch-nodes/input-number', # FIXME: when we have an enum type
  #'TypeKind.POINTER:8' => 'xod/patch-nodes/input-number', # pointers are bits # FIXME: this is actually a pointer to something
  'TypeKind.VOID:-2' => 'void', # special
  # bool => 'xod/patch-nodes/input-boolean', cruft I think
  # LVALUEREFERENCE is handled by to_xod_type IFF the type is this class
  );
my %danger_types; @danger_types{
  # generate a warning about the size of these types
  'TypeKind.LONG:8',
  'TypeKind.ULONG:8',
  'TypeKind.DOUBLE:8',
  } = (undef,);

# A .cpp for constructors looks like this:
my $cpp_constructor = <<'EOS'; # use {% ... %} interpolations
//-- constructor {% arduino.class_name %}({% constructor.argument_names.join(", ") %})
#pragma XOD require "{% arduino.github_url %}"

// Include C++ library:
{{#global}}
#include <{% arduino.dot_h_basename %}>
{{/global}}

// Our namespace should be: {% cpp.cons_namespace %}
// Reserve the space for the object.
struct State {
  uint8_t mem[sizeof({% arduino.class_name %})];
  };
using Type = {% arduino.class_name %}*; // 'Type' is assumed by xod code-generator

{{ GENERATED_CODE }}

void evaluate(Context ctx) {
  // It should be evaluated only once on the first (setup) transaction
  if (!isSettingUp()) return; // FIXME: relax this?

  auto _state = getState(ctx);

  // var names are valid c++ because we got them from the arglist of the c++ constructor
  {% FOREACH arg = $constructor.arguments %}
    auto {% arg.name %} = static_cast<{% arg.type_name %}> (getValue<input_{% arg.name %}>(ctx)); // {% arg.type_name %}
  } 
  {% END %}

  Type object = new (_state->mem) {% arduino.class_name %}( {% constructor.argument_names.join(", ") %} );

  emitValue<output_{% cpp.cons_patch_name %}>(ctx, object);
  emitValue<output_done>(ctx, object);
}
EOS

my $cpp_method = <<'EOS';
//-- {% method.type %} {% arduino.class_name %}::{% method.name %}({% method.argument_names.join(", ") %})
// Our constructor namespace should be: {% cpp.cons_namespace %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  // only act on trigger, inputs not relevant for this
  if ( !isInputDirty<input_trigger>(ctx) ) return;

  // var names are valid c++ because we got them from the arglist of the c++ method
  {%- FOREACH arg = method.arguments %}
  auto {% arg.name %} = static_cast<{% arg.type_name %}> (getValue<input_{% arg.name %}>(ctx)); // {% arg.type_name %}
  {%- END %}

  auto _object = getValue<input_{% xod.cons_patch_name %}>(ctx); // {% arduino.class_name %}

  {% IF method.type != 'void' %}auto _rez = {% END %}_object->{% method.name %}( {% method.argument_names.join(", ") %} ); // {%
    method.type != 'void' 
    ? method.type
    : 'void'
  %}
  
  emitValue<output_dev>(ctx, _object); // convenience

  {%- IF method.type != 'void' %}
  emitValue<output_val>(ctx, _rez); // {% method.type %}
  {%- END %}
  emitValue<output_done>(ctx, 1); // pulse
}
EOS

my $cpp_static_method = <<'EOS';
//-- {% $method{'type'} %} {% $arduino->class_name-> %}::{% $method{'name'} %}({% our @args = map {$_->{'name'}} @{$method{'arguments'} }; join(", ", @args); %})
// Our constructor namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  {% 
  if (@{$method{'arguments'}}) {
    $OUT .= "if (\n    ";

    our @dirty;
    push @dirty, "!isInputDirty<input_".$xod{'cons_patch_name'}.">(ctx)";
    foreach my $arg ( @$args ) {
      push @dirty, "!isInputDirty<input_".$arg->{'name'}.">(ctx)";
    } 
    $OUT .= join " &&\n    ",@dirty;
    $OUT .= "\n  ) return;";
    }
  else { '// no inputs' }
  %}

  // var names are valid c++ because we got them from the arglist of the c++ method
  {% 
  foreach my $arg ( @{$method{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = static_cast<".$arg->{'type_name'}."> (getValue<input_".$arg->{'name'}.">(ctx)); // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  {% ($method{'type'} ne 'void') ? 'auto _rez = ' : '' %}{% $arduino->class_name %}::{% $method{'name'} %}( {% join(", ", @args) %} ); // {%
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'void'
  %}
  
  emitValue<output_{% $method{'type'} ne 'void' ? 'val' : 'done' %}>(ctx, {% $method{'type'} ne 'void' ? '_rez' : 1 %}); // {% 
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'pulse';
  %}
}
EOS

my $cpp_property = <<'EOS';
//-- {% $property{'type'} %} {% $arduino->class_name %}::{% $property{'name'} %} getter/setter
// Our constructor namespace should be: {% $cpp{'cons_namespace'} %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  // Seems like an ugly pattern...

  // Set the value if incoming value is dirty (and emit it)
  if ( isInputDirty<input_val> ) {
    auto value  = getValue<input_val>(ctx); // {% $property{'type'} %}
    auto _object  = getValue<input_{% $xod{'cons_patch_name'} %}>(ctx); // {% $arduino->class_name %}
    _object->{% $property{'name'} %} = value;

    emitValue<output_dev>(ctx, _object);
    emitValue<output_out>(ctx, value);
    emitValue<output_done>(ctx, value);
  }

  // Emit the value if object is dirty ? or by pulse?
  else if ( isInputDirty<input_{% $xod{'cons_patch_name'} %}> ) {
    auto _object  = getValue<input_{% $xod{'cons_patch_name'} %}>(ctx); // {% $arduino->class_name %}
    auto value = _object->{% $property{'name'} %};

    emitValue<output_dev>(ctx, _object);
    emitValue<output_out>(ctx, value );
    emitValue<output_done>(ctx, value);
    }

  else {
    // not dirty, do nothing
    }

}
EOS

sub do_make {
  # --- ardlibdir
  my ($arddir) = @ARGV;
  my $ard = arduino_new($arddir);
  say "# Start library for $arddir";
  my $xod = _do_library($ard);
  say "# Constructors for $ard, @ $xod";
  do_constructor();
  say "# Methods for $ard, @ $xod";
  do_methods();
  say "# Static Methods for $ard, @ $xod";
  do_static_methods();
  #do_properties(); # skip them
  say "# Specializers $ard, @ $xod";
  do_specialize();

  add_warnings($ard);
  say "# Made $xod";
  }

sub add_warnings {
  # update readme patch
  my ($ard) = @_;
  my $xod = xod_lib_dir($ard);

  my $xodp = decode_json( `cat $xod/readme/patch.xodp` );

  $xodp->{'comments'}->[0]->{'content'} .= "\n\nWarnings:\n* ".join("\n* ",@warnings);

  write_patch("$xod/readme/patch.xodp", $xodp);

  }

sub xod2xodball {
  # simple name derivation: just the leaf
  my ($xoddir) = @_;
  basename($xoddir) . ".xodball";
  }

sub xodball2tmp {
  # xodball to unpacked tmp dir
  # check for sanity yourself
  my ($xodball) = @_;
  my $leaf = basename($xodball,'.xodball');

  my $path = "/tmp/xodball";
  # FIXME if lib, put in $author/$name
  $path .= "/".$leaf;

  $path;
  }

sub do_pack {
  # --- $xodprojectdir # > /tmp/
  fail_with_help("Expected a project-dir",'pack') if !@ARGV;

  foreach my $xod (@ARGV) {

    if (!-d $xod || !-e $xod || (basename($xod) =~ /\.xodball$/) ) {
      say STDERR "# Expected a project-directory, but it's not: $xod";
      exit 1;
      }

    if (! -e "$xod/project.xod") {
      say STDERR "# Expected a project-directory with a project.xod, but it's not: $xod";
      exit 1;
      }
    
    my $xodtmp = "tmp/".xod2xodball($xod);
    say "INTO $xodtmp";
    system('mkdir','-p', 'tmp') and die;
    my @cmd = (xodc,'pack', $xod, $xodtmp);
    system(@cmd) and die;
    say "# packed: $xodtmp";
    }
  }

sub do_unpack {
  # --- $xodprojectdir # > /tmp/
  fail_with_help("Expected a .xodball",'unpack') if !@ARGV;

  foreach my $xod (@ARGV) {

    if (-d $xod || !-e $xod || (basename($xod) !~ /\.xodball$/) ) {
      say STDERR "# Expected a .xodball, but it's not: $xod";
      exit 1;
      }
    
    my $xodtmp = xodball2tmp( $xod );
    say "INTO $xodtmp";
    system('mkdir','-p', $xodtmp) and die;
    my @cmd = (xodc,'unpack', $xod, $xodtmp."/x");
    system(@cmd) and die;
    say "# unpacked: $xodtmp";
    }
  }

sub cpp_safe_token {
  my ($a) = @_;
  $a =~ s/-/_/g;
  die "bad token, can't cpp'ize it: '".$_[0]."'" if $a =~ /[^A-Za-z0-9_]/;
  $a
  }

sub foreach_method {
  # given an ast whose top is a list of methods (or constructors)
  # and, the definitions()
  # call the block with ($ct, {infoaboutmethod}, \@inputs)
  # where method is: { name=> , type=>$return_type, type_name=> }
  # where inputs are a list of [ $input_name, $xod_type, $type_name ];
  my ($defn, $methods_ast, $block) = @_;
  my $ct = 0;
  say "Count of nodes: ".@$methods_ast;
  METHOD:
  foreach my $method (@$methods_ast) {
    next if $gSwitches->{'only'} && $method->{'text'} ne $gSwitches->{'only'};
    debug sub { "method " . $method->{'text'} };

    my $args_ast = find_all(0, $method, \&p_toplevel, p_node_type('PARM_DECL'));
    debug "  parms ".dump_shallow($_) foreach @$args_ast;

    my @inputs; # [ $name, $xodtypename, $actual-spelled-type ]
    my @saw = $method->{'text'} . "("; # for error message
    #say "  --- args...";
    my $parm_ct = 0;
    foreach my $parm (@$args_ast) {
      $parm_ct += 1;
      my $input_name = $parm->{'text'};
      $input_name = cpp_safe_token($input_name);

      # rename for "reserved" names
      if ( (grep {$_ eq $input_name} @ReservedVariableNames) || $_ eq $defn->{'cpp'}->{'cons_patch_name'} || $_ eq $defn->{'xod'}->{'cons_patch_name'}) {
        $input_name .= $parm_ct;
        }

      my $full_type = $parm->{'type'}; # unparsed, sad. "int *", "bool ()"
      push @saw, "$full_type $input_name, ";

      my $xod_type = to_xod_type($defn, \@saw, $parm); # can throw "Don't know cpp type:..."
      if ( ! $xod_type ) {
        push @warnings, "Skipped ".$method->{'text'}."(..) (line ".$method->{'line'}.") because we don't know the parameter type $full_type";
        say "# ",$warnings[-1];
        next METHOD;
        }

      my $type_name = $parm->{'type_name'};
      debug sub { "  param (safed) '$input_name' : '$full_type' ($type_name) -> '$xod_type' " };
      push @inputs, [ $input_name, $xod_type, $type_name ];
      }

    # just check output type
    if ( $method->{'node'} eq 'CONSTRUCTOR' ) {
      debug sub { "  constructor, returns self " };
      }
    else {
      my $outtype = to_xod_type($defn, [ $method->{'type_name'}."/".$method->{'return_type'}." ".$method->{'text'}."(" ], $method );
      if ( ! $outtype ) {
        say "method ",dump_shallow($method);
        push @warnings, "Skipped ".$method->{'text'}." (line ".$method->{'line'}.") because we don't know the output type ".$method->{'type_name'}."/".$method->{'return_type'};
        say "# ",$warnings[-1];
        next;
        }
      debug sub { "  output: '".$method->{'type'}."' -> '$outtype'" };
      }

    debug sub { "Inputs: ",Dumper(\@inputs); };
    #say "method ".$method->{'text'}."(",join(", ", map {$_->[0]} @inputs),")";

    &$block( $ct, { name=> $method->{'text'}, type=>($method->{'return_type'} || $method->{'type'}), type_name=>$method->{'type_name'} }, \@inputs );

    $ct += 1;
    }
  $ct;
  }

sub to_xod_type {
  my ($defn, $saw, $parm) = @_;
  my $full_type = $parm->{'type'} eq 'TypeKind.FUNCTIONPROTO:1' ? $parm->{'return_type'} : $parm->{'type'};
  my ($base_type, @more_type_pieces) = split(" ",$full_type);

  my $xod_type;

  # for return, we can't assume it's "this", so return it possibly as duplicate
  if ( ($base_type eq 'TypeKind.LVALUEREFERENCE:1') && $parm->{'type_name'} eq ($defn->{'arduino'}->class_name . ' &') ) {
    # $Class &
    #say "REF";
    $xod_type = "@/input-".$defn->{'xod'}->{'cons_patch_name'};
    }
  else {
    $xod_type = $cpp2xod_type{$base_type};
    }

  if (!$xod_type) {
    {
    local $Data::Dumper::Maxdepth=1;
    say Dumper($parm);
    }
    my $sofar = join "", @$saw;
    say "Don't know type for argument '".$parm->{'text'}."' in $sofar,...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
    return undef;
    }
  if  (exists $danger_types{$base_type}) {
    my $sofar = join "", @$saw;
    push @warnings, "Dangerous type conversion from '$base_type', for argument '".$parm->{'text'}."' in $sofar,...)";
    }
  $xod_type;
  }

sub do_ast {
  # just dump the ast
  # --- $ardlib
  my ($ard) = @ARGV;
  my $dot_h = $ard->dot_h;
  system("python", "./dump_ast.py", $dot_h);
  exit($?);
  }

sub do_properties {
  # Make public property patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;

  $gSwitches->{'limit'} = 5 if !$gSwitches->{'limit'};

  make_patches(
    'property',
    $ard, $xod,
    $cpp_property,
    # description_maker,
    sub {
      my ($defn, $property_node, $args, $ct) = @_;
      "property " . $property_node->{'text'}; # FIXME: use "doc" and comments etc
      },

    # xodp_maker,
    sub {
      my ($defn, $xodp, $property, $args, $ct) = @_;

      # each "row" of a patch
      my $xod_input_type = to_xod_type($defn, [], $property);

      add_nodes($xodp, 
        [ $defn->{'cpp'}->{'cons_patch_name'} => $defn->{'xod'}->{'input_type_name'} ],
        [ val => $xod_input_type ]
        );

      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      my $outtype = $xod_input_type; # same
      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      add_nodes($xodp, 
        [ out => $outtype],
        [ dev => $defn->{'xod'}->{'output_type_name'} ] 
        );
      },

    # template_data,
    sub {
      my ($defn, $property, $args) = @_;
      return { property => {
        name => $property->{'name'},
        type => $property->{'type_name'},
        }};
      },

    # ast preds
    [ p_node_type('FIELD_DECL'), p_access('PUBLIC') ],
    );
  }

sub definitions {
  # common values we need from $ard/$xod stuff
  # returns $defn
  my ($ard, $xod, $xod_is_new) = @_;
  state %cache;

  if ($cache{$ard->dir}) {
    return %{ $cache{$ard->dir} };
    }

  my $libname;
  $libname = xod_lib_name($ard);
  if ( $libname =~ /[^a-zA-Z0-9\/-]/ ) {
    die "xod dir for libraries must only use valid xod chars: [a-zA-Z0-9-], saw '$libname' from '$xod'" 
    }

  if (!$xod_is_new && !-e "$xod/project.xod") {
    die "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $dot_h = $ard->dot_h;

  my %defn = (
    # values we need, categorized to reduce confusion
    # usable by the makers(), and the template
    arduino => $ard, # from arduino world
    cpp => {}, # tokens that are for cpp
    xod => {}, # tokens that are for xod
    );

  $defn{'xod'}->{'libname'} = $libname;
  $defn{'xod'}->{'cons_patch_name'} = lc( $ard->class_name ); # base typename & patchname # WAS $cons_patch_name
  $defn{'xod'}->{'cons_patch_name'} =~ s/_/-/g; # xod wants -
  if ($BUG{'type_name_dash'} ) { $defn{'xod'}->{'cons_patch_name'} =~ s/-//g; }; # remove -
  
  my $type_base = '@'; # lib || project
  $defn{'xod'}->{'input_type_name'} = $type_base . "/input-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  $defn{'xod'}->{'output_type_name'} = $type_base . "/output-" . $defn{'xod'}->{'cons_patch_name'}; # WAS type_name_input
  
  $defn{'cpp'}->{'cons_patch_name'} = $defn{'xod'}->{'cons_patch_name'}; # WAS cpp_patch_name
  $defn{'cpp'}->{'cons_patch_name'} =~ cpp_safe_token( $defn{'cpp'}->{'cons_patch_name'} ); # cpp wants _
  
  $defn{'cpp'}->{'cons_namespace'} = xod_lib_name($ard); # WAS namespace
  $defn{'cpp'}->{'cons_namespace'} =~ s/\//__/g; # lib path / -> __ for cpp
  $defn{'cpp'}->{'cons_namespace'} .= "__" . $defn{'cpp'}->{'cons_patch_name'};
  $defn{'cpp'}->{'cons_namespace'} = cpp_safe_token( $defn{'cpp'}->{'cons_namespace'} );
  #say "## defn: ",Dumper(\%defn);

  $cache{$ard->dir} = \%defn;
  return %defn;
  }

sub make_patches {
  # the factored code to generate patches from ast elements: methods
  # fill in the various makers

  my ($what, $ard, $xod, $template, $description_maker, $xodp_maker, $template_data, $ast_predicates) = @_;
  
  my %defn = definitions( $ard, $xod );
  my $class_ast = $defn{'arduino'}->class_ast;

  # What things are of interest to this patch maker? the @$ast_predicates
  my $methods_ast = find_all(0, $class_ast, @$ast_predicates);
  #print "found ${what}'s: ",dump_shallow($_),"\n" foreach @$methods_ast;
  if (!@$methods_ast) {
    warn "No ${what}'s";
    return;
    }

  my %method_counts = ();
  my $made_ct = foreach_method(\%defn, $methods_ast, sub {
    my ($ct, $method, $args) = @_;

    # append ct if not first one
    my $this_method_name = $method->{'name'};
    $this_method_name .= $method_counts{$this_method_name} if $method_counts{$this_method_name};

    #say "patch ($what) name: $this_method_name";
    #say "  #args ",Dumper($args);

    my %xodp; # the .xodp structure for a constructor patch

    $xodp{'description'} = $description_maker ? $description_maker->(\%defn, $method, $args, $ct) : ""; # can we do better?
    #say "Description '",$xodp{'description'},"'";

    $xodp_maker->(\%defn, \%xodp, $method, $args, $ct);
    debug sub { "Patch for $what: $this_method_name ".Dumper(\%xodp); };

    # xodp_maker can provide name
    my $patch_name = delete $xodp{'patch_name'};
    if ($patch_name) {
      die "Patch name from the '$what' '$this_method_name' xodp_maker had non-xod chars in it [a-zA-Z-]: '$patch_name'" if $patch_name =~ /[^A-Za-z0-9-]/;
    } else {
      # fix patch name: dashify
      $patch_name = lcfirst($this_method_name);
      $patch_name =~ s/([A-Z])/'-'.lc($1)/eg;
      $patch_name =~ s/_-/-/g; # if there was _Cap
      #say "Dashified '$this_method_name' -> '$patch_name'";
      }
    if ($BUG{'type_name_dash'} && $method->{'node'} eq 'CONSTRUCTOR') {
      # type name == patch-name, but transpiler isn't doing global s/-/_/g;
      # so, drop -
      $patch_name =~ s/-//g;
      }

    #say "patch_name '$this_method_name' -> '$patch_name'";
    write_patch( "$xod/$patch_name/patch.xodp", \%xodp);
    
    #say "Method ",Dumper($method);
    # we assume the sub will modify/add only top-level keys
    my $new_data = $template_data->(\%defn, $method, $args, $ct);
    #say "new template data: ",Dumper($new_data);

    my %new_defn = (%defn, %$new_data);
    #say "template data: ",Dumper(\%new_defn);
    write_patch_cpp("$xod/$patch_name/patch.cpp", $template, \%new_defn);

    last if $gSwitches->{'limit'} && $gSwitches->{'limit'} < $ct+1;
    });
  say "Made ",$made_ct," $what patches";
  $made_ct;
  }

sub do_static_methods {
  # Make public static methods patches
  # --- $ardlib

  my ($arddir) = @ARGV;
  my $ard = arduino_new($arddir);
  my $xod = xod_lib_dir($ard);
  
  my $made_ct = make_patches(
    'static method',
    $ard, $xod,
    $cpp_static_method,

    # description
    sub { my ($defn, $method_node, $args, $ct) = @_; # unused
        ''; # can we do better? comments? doc? line-number?
      },

    # %xodp
    sub { 
      my ($defn, $xodp, $method, $args, $ct) = @_;

      # each "row" of a patch

      # inputs
      add_nodes($xodp, 

        # the args
        @$args,
        );

      # cpp
      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # output node(s)
      my $outtype = to_xod_type($defn, [], $method);

      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      if (!$outtype) {
        warn Dumper($method);
        die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }

      my @rez_nodes;

      if ($method->{'type'} eq 'TypeKind.VOID:-2') {
        push @rez_nodes, [ done => "xod/patch-nodes/output-pulse" ]; # pulse on finish
        }
      else {
        push @rez_nodes, [ val => $outtype ];
        }

      add_nodes($xodp, @rez_nodes );
      },

    # template-data
    sub {
      my ($defn, $method, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->github_url;

      return { method => {
        argument_names => [ map { $_->[0] } @$args ],
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC'), \&p_static ]
    );

  }

sub do_methods {
  # Make public methods patches
  # --- $ardlib

  my ($arddir) = @ARGV;
  my $ard = arduino_new($arddir);
  my $xod = xod_lib_dir($ard);
  
  my $made_ct = make_patches(
    'method',
    $ard, $xod,
    $cpp_method,

    # description
    sub { my ($defn, $method_node, $args, $ct) = @_; # unused
      ''; # can we do better? comments? doc? line-number?
      },

    # %xodp
    sub { 
      my ($defn, $xodp, $method, $args, $ct) = @_;
      debug "  args ".dump_shallow($_) foreach @$args;

      say "Method ", $method->{'name'}."(".(join ",", map{$_->[0]} @$args).")";
      # each "row" of a patch

      # inputs
      add_nodes($xodp, 

        # the object
        [$defn->{'cpp'}->{'cons_patch_name'} => $defn->{'xod'}->{'input_type_name'}], 

        # the args
        @$args,

        # the pulse
        [ trigger => "xod/patch-nodes/input-pulse" ] # pulse for "do it"
        );

      # cpp
      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # output node(s)
      my $outtype = to_xod_type($defn, [], $method );

      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      if (!$outtype) {
        warn Dumper($method);
        die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }

      my @rez_nodes;

      push @rez_nodes, [ dev => $defn->{'xod'}->{'output_type_name'}];
      debug sub { "  output 'dev' -> '".$defn->{'xod'}->{'output_type_name'}."'" };

      # Skip if void
      if ($method->{'type'} ne 'TypeKind.VOID:-2' ) {
        debug sub { "  xodp extra output 'val' -> '$outtype'" };
        push @rez_nodes, [ val => $outtype ];
        }

      push @rez_nodes, [ done => "xod/patch-nodes/output-pulse" ]; # pulse on finish

      add_nodes($xodp, @rez_nodes );
      },

    # template-data
    sub {
      my ($defn, $method, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->github_url;
      my @argument_info = map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args; # FIXME: use actual type
      debug sub { "# args ".join(', ', map { dump_shallow($_) } @argument_info ); };

      return { method => {
        argument_names => [ map { $_->[0] } @$args ],
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => \@argument_info, 
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC'), \&p_instance ]
    );

  }

sub do_constructor {
  # Make a constructor patch
  # --- $ardlib

  my ($arddir) = @ARGV;
  my $ard = arduino_new($arddir);
  my $xod = xod_lib_dir($ard);
  
  my $made_ct = make_patches(
    'constructor',
    $ard, $xod,
    $cpp_constructor,
    # description
    sub { my ($defn, $cons_node, $args, $ct) = @_; # unused
      # FIXME: also README?
      join "\n", (
        "constructor", # can we do better? comments? doc?
        $defn->{'arduino'}->github_url,
        "Arduino: ".$ard->class_name,
        "XOD: ".$defn->{'xod'}->{'input_type_name'},
        "cpp postfix: ".$defn->{'cpp'}->{'cons_patch_name'},
      );
      },
    # %xodp
    sub { 
      my ($defn, $xodp, $constructor_ast, $args, $ct) = @_;

      $xodp->{'patch_name'} = $defn->{'xod'}->{'cons_patch_name'} . ($ct==0 ? '' : $ct);
      say "Constructor: ", $xodp->{'patch_name'}."(".(join ",", map{$_->[0]} @$args).")";

      add_nodes($xodp, @$args);

      add_nodes($xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);

      # the pulse
      my $pulse = [ done => "xod/patch-nodes/output-pulse" ]; # pulse for "done"

      if ($ct == 0) {
        # FIXME: description => 'arduino: $classname, xod: $typename, cpp: $typename'
        # self creates a type using patch-name
        # There's a bug: the deduced type-name in the cons code from output-self is actually the label name, not the patch name
        add_nodes($xodp, [$defn->{'cpp'}->{'cons_patch_name'} => 'xod/patch-nodes/output-self'], $pulse);
        }
      else {
        add_nodes($xodp, [ dev => $defn->{'xod'}->{'output_type_name'}], $pulse );
        }
      },

    # template-data
    sub {
      my ($defn, $constructor_ast, $args) = @_;
      die "Need github_url from --gihub_url option, or from arduino library.properties['url']" if !$defn->{'arduino'}->github_url;

      return { constructor => {
        argument_names => [ map { $_[0] } @$args],
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        }}
      },
 
    # ast_predicates
    [ \&p_toplevel, p_node_type('CONSTRUCTOR'), p_access('PUBLIC') ]
    );

  }

sub write_patch_cpp {
  my ($fname, $template_str, $data) = @_;

  #say "Data: ",Dumper($data);

  my $template = Template->new(
    START_TAG => '{%',
    END_TAG => '%}',
    );

  my $cpp;
  $template->process( \$template_str, $data, \$cpp) || die( $template->error );
  my $fh = IO::File->new( $fname, 'w') or die($!);
  print $fh $cpp;
  $fh->close;
  say "Make cpp $fname";
  }

sub write_patch {
  my ( $fname, $xodp ) = @_;
  say "Make patch $fname ...";
  system('mkdir','-p', dirname($fname) ) and die;
  my $xh = IO::File->new( $fname, 'w' ) or die($!);
  print $xh JSON->new->pretty->canonical->encode($xodp);
  $xh->close;
  }


sub add_nodes {
  my ($xodp, @inputs) = @_;
  # inputs are a list of [name => type] in order
  # This is one "row" of inputs, arranges these across
  # creates id, position

  #say "Update xodp ",Dumper($xodp);

  $xodp->{'nodes'} ||= [];
  my $nodes = $xodp->{'nodes'};

  my $row_y = (($nodes->[-1] || {})->{'position'} || {})->{'y'};
  $row_y = defined($row_y) ? $row_y + $XODRowSize : $XODRowSize; # start not in corner
  #say "Row ",$row_y/$XODRowSize;

  #say "inputs; ",Dumper(\@inputs);
  my $x = 2 * $XODColSize; # start not in corner
  my $in_ct = 0;
  foreach my $nt (@inputs) {
    my ($name,$type) = @$nt;

    # The id is "stable": if you generate a 2nd time, should be same id
    # this lets already existing patches continue to work
    # We might as well just use the label, since they are unique anyway
    my $id;
    if ($name) {
      # first letter of input/output
      $id .= substr( (split('/', $type))[-1], 0, 1 );
      $id .= "-";
      # the label
      $id .= $name;
      }
    elsif ( $type eq 'xod/patch-nodes/not-implemented-in-xod' ) {
      $id = 'cpp';
      }
    else {
      # what other ones don't have id?
      warn "Expected all un-named nodes to have an id, except xod/patch-nodes/not-implemented-in-xod. This was $type";
      $id = next_xod_id();
      }

    my %node;
    $node{'id'} = $id;
    $node{'label'} = $name if $name; # some nodes have no name, e.g. not-implemented-in-xod
    $node{'type'} = $type;
    $node{'position'} = { x => $x, y => $row_y };
    # warn "# node ",$node{'label'}," [",$node{'id'},"] as ",$node{'type'};

    
    push @$nodes, \%node;

    $x += 2 * $XODColSize;
    $in_ct += 1;
    }
  }

sub next_xod_id {
  # 9 char id
  # start/end with alpha
  state $alpha = ['A'..'Z', 'a'..'z'];
  state $alphanum = [ @$alpha, '0'..'9','-' ];
  $alpha->[ rand( scalar @$alpha ) ] . (join "",map { $alphanum->[ rand( scalar @$alphanum ) ] } (1..7)) . $alpha->[ rand( scalar @$alpha ) ];
  }

sub p_toplevel {
  # if node is toplevel
  my ($depth, $node) =@_;
  $depth == 0;
  }

sub p_static {
  # static
  my ($depth, $node) =@_;
  $node->{'static'};
  }

sub p_instance {
  # not static
  my ($depth, $node) =@_;
  ! $node->{'static'};
  }

sub p_access {
  my ($access_type) = @_; # PUBLIC PROTECTED PRIVATE etc.
  die "Expected PUBLIC|PROTECTED|PRIVATE" if $access_type !~ /^PUBLIC|PROTECTED|PRIVATE$/;
  sub {
    my ($depth, $node) =@_;
    $node->{'access'} eq $access_type;
    }
  }

sub p_node_type {
  my ($type) = @_;
  sub {
    my ($depth, $node) =@_;
    $node->{'node'} eq $type;
    }
  }

sub dump_shallow {
  my ($node) = @_;
  local $Data::Dumper::Maxdepth=1;
  local $Data::Dumper::Indent=0;
  Dumper($node);
  }

sub find_first {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, 'first', @preds);
  }

sub find_all {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, undef, @preds);
  }

sub find {
  # find the first child node for and(....)
  my ($depth, $ast, $onfirst, @preds) = @_;
  #say "start ",dump_shallow($ast) if $depth==0;
  # say "  preds ",join(" ",@preds);

  my @found;
  foreach my $child ( @{ $ast->{'children'} || [] } ) {
    my $hit = 1;
    #say "  child: ",dump_shallow($child);
    foreach my $pred (@preds) {
      if (! &$pred( $depth, $child ) ) {
        $hit = 0;
        last;
        }
      }
    if ($hit) { 
      #say "  HIT ",dump_shallow($child);
      return $child if $onfirst; 
      push @found, $child;
      }
    else {
      #say "Nope $depth";
      }

    find($depth+1, $child, $onfirst, @preds);
    }
  \@found;
 }

sub do_library {
    # make the library bits
    # --- $ardlib # > xod_libraries/$author/$arddir

    my $any;
    foreach my $ard (@ARGV) { 
      _do_library($ard);
      $any = 1;
      }
    fail_with_help("# Expected at least 1 arduino library", 'library') if !$any;
    }

sub xod_lib_name {
  my ($ard) = @_;
  my $xod = xod_lib_dir($ard);
  $gSwitches->{'project'} ? basename($xod) : basename(dirname($xod)) . "/" .basename($xod);
  }

sub xod_lib_dir {
  # Derive the xod-lib-name from the arduino-lib-name
  # --xoddir forces it to a specific dir name
  # --project forces it to a project instead of library
  my ($ard) = @_;
  # lib-dir: $xod/__lib__/$user/$ardlibname-ll

  return $gSwitches->{'xoddir'} if $gSwitches->{'xoddir'};

  my $lib_name = lc( $ard->lib_property('name') );
    $lib_name =~ s/[_ ]/-/g;
    $lib_name =~ s/[^0-9a-z\/-]//g;
 
  my $lib_dir = ($gSwitches->{'project'}) ? xod_projects : xod_libraries;

  $lib_dir .= "/" . ($gSwitches->{'author'} || config()->{'xod'}->{'username'}) if !$gSwitches->{'project'};
  $lib_dir .= "/" . $lib_name;
  $lib_dir .= '-ll';
  $lib_dir;
  }

sub _do_library {
    my ($ard) = @_;

    $ard->expected;

    my $subdir = xod_lib_dir($ard);
    if (!$gSwitches->{'dryrun'}) {
      system('mkdir','-p', $subdir) and die;
      }
    say "# made $subdir";

    # project.xod
    my $username = $gSwitches->{'author'} || config()->{'xod'}->{'username'};
    my @authors = grep {$_} (
      $username,
      $username ? "https://forum.xod.io/u/$username" : undef,
      config()->{'email'},
      $ard->lib_property('author'), 
      $ard->lib_property('maintainer')
      );

    my %defn = definitions( $ard, $subdir, 'xod-is-new' );
    my $ast = $ard->class_ast;

    my @description;
    # classname
    push @description, $defn{'xod'}->{'libname'};

    push @description, $ard->lib_property('sentence');
    push @description, $ard->lib_property('paragraph') if $ard->lib_property('sentence') ne $ard->lib_property('paragraph');

    push @description,'';
    push @description, "Mechanically converted by ".($username ? "https://forum.xod.io/u/$username" : '')." using github.com:awgrover/arduino-2-xod from:";

    # $lib.name ($dirname) by $author. Version $version
    my $ardlibname = $ard->lib_property('name');
    my $arddirname = basename($ard->dir);
    push @description, $ardlibname . ($ardlibname eq $arddirname ? '' : " ($arddirname)" ) . " by ".$ard->lib_property('author'). ". Version ".$ard->lib_property('version');

    # url
    my $src_url = $ard->lib_property('github-url');
    if (!$src_url) {
      warn "No url from --github-url nor @{[$ard->dir]}/library.properties[url]\n";
      push @description, "Unknown source";
      }
    else {
      push @description, $ard->lib_property('github-url');
      }

    my %xod_project = (
        authors => \@authors,
        name => $defn{'xod'}->{'libname'},
        description => join("\n",@description),
        version => ($gSwitches->{'version'} || '1.0.0'),
        license => config()->{'license'} || 'GPLv3',
        );

    # FIXME: replace keys rather than overwriting all keys
    my $ph = $gSwitches->{'dryrun'} ? *STDOUT : IO::File->new("$subdir/project.xod",'w') or die($!);
    print $ph JSON->new->pretty->canonical->encode(\%xod_project);

    say "# Description:";
    say join("\n",@description);
    say "";
    say "# wrote $subdir/project.xod";


    my %xodp = (
      comments => [
        {
        content => join("\n",@description),
        id => 'readme',
        position => { x=>0, y=>0 },
        size => { height=>555,width=>510 },
        },
        ]
      );
    write_patch( "$subdir/readme/patch.xodp", \%xodp);

    if (!$gSwitches->{'project'}) {
      # link as project
      my $project_name = basename($defn{'xod'}->{'libname'});
      system('rm', xod_projects."/$project_name") if -e dirname(xod_libraries)."/$project_name";
      my @cmd = ('ln','-s', $subdir, xod_projects."/$project_name");
      unshift @cmd, 'echo' if $gSwitches->{'dryrun'};
      system(@cmd) and die($!);
      say "linked project $project_name to that lib";
      }
    
    $subdir;
    }

sub arduino_new {
  # with switches
  my ($arddir) = @_;
  Arduino->new( dir => $arddir, known_dot_h => $gSwitches->{'dot_h'}, known_github_url => $gSwitches->{'github-url'} );
  }

sub do_specialize {
  # gate, if, and so on
  # --- $ardlib

  my ($arddir) = @ARGV;
  my $ard = arduino_new($arddir);
  my $xod = xod_lib_dir($ard);

  my %defn = definitions( $ard, $xod );
  my $ast = $ard->class_ast;

  my $xod_builtin_lib = '/usr/lib/node_modules/xod-cli/__lib__';

  my @abstract_xodp_file = split "\n", `rgrep -l xod/patch-nodes/abstract $xod_builtin_lib --include '*.xodp'`;
  #say "abs ",join(", ",@abstract_xodp_file);

  foreach my $an_abstract_xodp_file (@abstract_xodp_file) {
    my $patch_name = basename(dirname($an_abstract_xodp_file));
    #say "Abstract patch $patch_name";

    my $this_patch_name = "$patch_name(".$defn{'cpp'}->{'cons_patch_name'}.")";

    my $xodp = specialize_xodp($xod, \%defn, $patch_name, $this_patch_name, $an_abstract_xodp_file);
    my $could = specialize_cpp($xod, $xod_builtin_lib, \%defn, $patch_name, $this_patch_name, $xodp, $an_abstract_xodp_file);

    if (!$could) {
      say "  for $patch_name, couldn't do .cpp, so remove useless files";
      system('rm', '-rf', "$xod/$this_patch_name");
      }
    }
  }

sub specialize_cpp {
  my ($xod, $xod_builtin_lib, $defn, $patch_name, $this_patch_name, $xodp, $an_abstract_xodp_file) = @_;
  my $extant_specialized_name = "$patch_name(number)/patch.cpp";
  #say "From $extant_specialized_name ..";
  my $extant_specialized_file = `find $xod_builtin_lib -path '*/$extant_specialized_name'`;
  chomp $extant_specialized_file;
  if (!$extant_specialized_file) {
    warn "Warning: Can't find an exemplar for '$patch_name', like '*/$extant_specialized_name'\n";
    return 0;
    }

  say "From $extant_specialized_file ..";
  say "Wrote $xod/$this_patch_name/patch.cpp";
  my $rez = system('cp', $extant_specialized_file, "$xod/$this_patch_name/patch.cpp");

  return !$rez;
  }

sub specialize_xodp {
  my ($xod, $defn, $patch_name, $this_patch_name, $an_abstract_xodp_file) = @_;
  # makes the "specialized" nodes for things like if-then-else
  # by copying existing ones

  my $xodp = decode_json( `cat $an_abstract_xodp_file` );
  #say "json: ",Dumper($xodp);

  # for un-labeled inputs, if only 1, then "IN", if more, then "IN1"..
  # so, we may have to fixup the first

  my ($firstin, $firstout); # {'node'}[n] entries
  my ($inct, $outct) = (1,1);
  foreach my $node (@{$xodp->{'nodes'}}) {
    # we'll implement it, so:
    if ($node->{'type'} eq 'xod/patch-nodes/abstract') {
      $node->{'type'} = 'xod/patch-nodes/not-implemented-in-xod';
      }
    # we do concrete types
    else {
      if ($node->{'type'} =~ /xod\/patch-nodes\/(input|output)-t([0-9])/) {
        my $in = $1 eq 'input';
        die "Don't know how to deal with $an_abstract_xodp_file, saw ".$node->{'type'}." for t>1" if ($2 ne '1');

        $node->{'type'} = $in ? $defn->{'xod'}->{'input_type_name'} : $defn->{'xod'}->{'output_type_name'};
        }
      if (!$node->{'label'}) {
        # unlabeled
        my $in = $node->{'type'} =~ /\/input-/;
        # remember for fixup
        if ($in) {
          if ($inct == 1) {
            $node->{'label'} = "IN";
            $firstin = $node 
            }
          else {
            $node->{'label'} = "IN$inct";
            }
          $inct += 1;
          }
        else {
          if ($outct == 1) {
            $node->{'label'} = "OUT";
            $firstout = $node 
            }
          else {
            $node->{'label'} = "OUT$outct";
            }
          $outct += 1;
          }
        }
      }
      #say "  ".$node->{'label'}." => ".$node->{'type'};
    }
  # fixup firsts
  if ($inct > 2) {
    $firstin->{'label'} .= '1';
    #say "  FIXUP in to ",$firstin->{'label'};
    }
  if ($outct > 2) {
    $firstout->{'label'} .= '1';
    #say "  FIXUP out to ",$firstout->{'label'};
    }
  
  #say "Abstract patch $this_patch_name";
  write_patch( "$xod/$this_patch_name/patch.xodp", $xodp);
  return $xodp;
  }

sub do_capture {
  my ($xod) = @ARGV;
  # we tend to build into xod_libraries/__lib__
  # so, we should capture for this .git

  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $libname = basename($xod);
  my $author = basename(dirname($xod));
  system('rm','-rf', "xod/__lib__/$author/$libname") and die($!);
  system('cp', '-R', $xod, "xod/__lib__/$author") and die($!);
  say "# cp'd everything to xod/__lib__/$author/$libname";
  }

sub do_github_fetch {
  # given the github like: https://github.com/prenticedavid/MCUFRIEND_kbv
  # add https://github.com/prenticedavid/MCUFRIEND_kbv/archive/master.zip
  # download, unzip

  my ($url) = @ARGV;

  # known .zip path
  if ($url !~ /\/master\.zip$/) {
    $url .= "/archive/master.zip";
    }
  
  my $libname = basename( dirname( dirname( $url ) )); # eh, hackish
  say "lib '$libname'";

  # moderately safe quoting
  say "Downloading $url, into tmp/$libname.zip";
  system("mkdir -p tmp && cd tmp && curl -L '$url' > '$libname.zip' && unzip '$libname.zip' && mv '$libname-master' '$libname'") and die($!);
  say "Downloaded unzipped into tmp/$libname";
  }

my %ConfigDesc = (
  xod => {
    username => 'xod account username for author',
    },
  email => 'email for contact by library users',
  path => {
    'xodc' => 'the xodc tool for pack/unpack',
    'xod_libraries' => 'path to XOD libraries',
    'xod_projects' => 'path to XOD projects',
    'libclang' => "path to libclang shared library, that python's clang.cindex.Config.set_library_file() will accept, libclang.so.1 on linux.",
    }
  );

sub do_config {
  say "# .config is json";
  print JSON->new->pretty->canonical->encode(\%ConfigDesc);
  }

sub config {
  state $config;

  if ($config) {
    return $config;
    }

  if (!-e '.config') {
    $config = {};
    }
  else {
    $config =  decode_json( `cat .config` );
    die "Expected a hash from .config" if ref($config) ne 'HASH';
    }

  # sub-parts
  #$config->{'xod'} ||= {};

  return $config;
  }

my %commands = (
    make => [
        ''=>'--- ardlibdir # Make the xod library from an arduinio ide lib',
        'github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'help|h|H'=>'this',
        ],
    # Parts
    library => [
        ''=>'--- ardlibdir # Make the xod library dir/properties',
        'version:s' => 'Use this version for the project/library (0.0.0), default is 1.0.0',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'project' => 'Create a xod project, not a library',
        'xoddir:s' => 'Create library here, default is $xod/__lib__/$xod.username/$ardlib.name-ll',
        'author' => 'Use this as the xod-author, default is ./.config[xod][username]',
        'dryrun|n' => 'Don\'t make changes',
        'help|h|H'=>'this',
        ],
    constructor => [ 
        ''=>'--- ardlibdir # Make the constructor nodes',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'xoddir:s' => 'Update library here, default is $xod/__lib__/$xod.username/$ardlib.name-ll',
        'github-url:s' => 'The github-url for the ard library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    methods => [ 
        ''=>'--- ardlibdir # Make the public method nodes',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'xoddir:s' => 'Update library here, default is $xod/__lib__/$xod.username/$ardlib.name-ll',
        'only:s' => 'only make this exact method name',
        'limit:n' => 'only make this many methods',
        'help|h|H'=>'this',
        ],
    static_methods => [ 
        ''=>'--- ardlibdir # Make the public static method nodes',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'xoddir:s' => 'Update library here, default is $xod/__lib__/$xod.username/$ardlib.name-ll',
        'only:s' => 'only make this exact method name',
        'limit:n' => 'only make this many methods',
        'help|h|H'=>'this',
        ],
    specialize => [
        ''=>'--- ardlibdir # create specialization patches',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'xoddir:s' => 'Update library here, default is $xod/__lib__/$xod.username/$ardlib.name-ll',
        'limit:n' => 'only make this many properties',
        'help|h|H'=>'this',
        ],
    properties => [ 
        ''=>'--- ardlibdir xod-proj-dir # see output of "library" for xod-proj_dir # Make the public property nodes',
        'project' => 'Create a xod project, not a library',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
        'limit:n' => 'only make this many properties',
        'help|h|H'=>'this',
        ],
    capture => [
      '' => '--- xod-proj-dir # copy into xod-dir __lib__',
      ],
    # util
    'github-fetch' => [
      '' => '--- github-url # makes assumptions and downloads the arduino lib from there',
      'help|h|H'=>'this',
      ],
    ast => [ 
      '' => '--- ardlibdir # dump the ast',
        'dot-h:s' => 'Name of the .h file, default is to deduce it',
      'help|h|H'=>'this',
      ],
    pack => [
        ''=>'--- some-project # Pack a .xodball into /tmp/$something.xodball',
        'help|h|H'=>'this',
        ],
    unpack => [
        ''=>'Unpack a .xodball into /tmp/xodball/* for further processing',
        'help|h|H'=>'this',
        ],
    config => [
      '' => 'describe .config file',
      ],
    );

sub fail_with_help {
    my ($msg, $command) = @_;
    say STDERR $msg;
    @ARGV = qw('--help');
    while(my ($c,$opdef) = each(%commands)) {
        local $0 = "$0 $c";
        awgrover::Getopt::xprintSwitchHelp(@$opdef);
        }
    exit 1;
    }

sub main {
    my $command = shift @ARGV;
    fail_with_help( "# Expected a command", undef ) if !defined($command);

    my $whichopts = $commands{$command};
    fail_with_help( "# Expected a command", undef ) if !defined($whichopts);

    $awgrover::Getopt::gUndefIfFail=1;
    $gSwitches = awgrover::Getopt::GetOptions( @$whichopts );
    exit(1) if !$gSwitches;

    $command =~ s/-/_/g;

    no strict 'refs';
    &{"do_".$command}();
    use strict 'refs';
    }

main();
