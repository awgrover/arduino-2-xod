#!/usr/bin/env perl
# Make a XOD low-level library automatically from a Arduino IDE library
# --- command [options] $arduino-library-directory

use strict; use warnings; no warnings 'uninitialized'; use 5.012; no if ($^V ge v5.18.0), warnings => 'experimental::smartmatch';
use Carp; $SIG{__DIE__} = sub { Carp::confess @_ };
use Data::Dumper;
use File::Basename qw(basename dirname);
use JSON;
use Text::Template; # it was there

use lib 'bin';
use awgrover::Getopt;

my $XODRowSize = 102; # seems to be every 102 pixels
my $XODColSize = 34; # seems to be

# FIXME: hard code xod location
my $xoddir = "/home/".$ENV{'USER'}."/xod/__lib__"; # can we ask xod?
my $xodc = "/home/awgrover/dev/thirdparty/xod/xodc"; # installed xodc is broken, use built

# Types we know how to translate to xod
# (plus the "class" type of interest of course)
my %cpp2xod_type = (
  # we could handle * types with more info here:
  'TypeKind.INT:4' => 'xod/patch-nodes/input-number', # ints are bytes
  'TypeKind.INT:2' => 'xod/patch-nodes/input-number',
  'TypeKind.INT:1' => 'xod/patch-nodes/input-number',
  'TypeKind.BOOL:1' => 'xod/patch-nodes/input-boolean',
  'TypeKind.POINTER:8' => 'xod/patch-nodes/input-number*', # pointers are bits
  'TypeKind.VOID:-2' => 'void', # special
  bool => 'xod/patch-nodes/input-boolean',
  );

# A .cpp for constructors looks like this:
my $cpp_constructor = <<'EOS'; # use {% ... %} interpolations
//-- constructor {% $arduino{'classname'} %}({% our @args = map {$_->{'name'}} @{$constructor{'arguments'} }; join(", ", @args); %})
#pragma XOD require "{% $arduino{'github_url'} %}"

// Include C++ library:
{{#global}}
#include <{% $arduino{'.h'} %}>
{{/global}}

// Our namespace should be: {% $namespace %}
// Reserve the space for the object.
struct State {
  uint8_t mem[sizeof({% $arduino{'classname'} %})];
  };
using Type = {% $arduino{'classname'} %}*; // 'Type' is assumed by xod code-generator

{{ GENERATED_CODE }}

void evaluate(Context ctx) {
  // It should be evaluated only once on the first (setup) transaction
  if (!isSettingUp()) return; // FIXME: relax this?

  auto state = getState(ctx);

  // var names are valid c++ because we got them from the arglist of the c++ constructor
  {% 
  foreach my $arg ( @{$constructor{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}."}>; // ".$arg->{'type_name'} ."\n  ";
  } 
  %}

  Type object = new (state->mem) {% $arduino{'classname'} %}( {% join ", ", @args; %} );

  emitValue<output_{% $typename %}>(ctx, object);
}
EOS

my $cpp_method = <<'EOS';
//-- {% $method{'type'} %} {% $arduino{'classname'} %}::{% $method{'name'} %}({% our @args = map {$_->{'name'}} @{$constructor{'arguments'} }; join(", ", @args); %})
// Our namespace should be: {% $namespace %}
struct State {
  // not used
  };

{{ GENERATED_CODE }}

void evaluate(Context ctx) {

  {% 
  if (@{$method{'arguments'}}) {
    $OUT .= "if (\n    ";

    our @dirty;
    push @dirty, "!isInputDirty<".$typename.">(ctx)";
    foreach my $arg ( @{$method{'arguments'} } ) {
      push @dirty, "!isInputDirty<".$arg->{'name'}.">(ctx)";
    } 
    $OUT .= join " &&\n    ",@dirty;
    $OUT .= "\n  ) return;";
    }
  else { '// no inputs' }
  %}

  // var names are valid c++ because we got them from the arglist of the c++ method
  {% 
  our @args;
  foreach my $arg ( @{$method{'arguments'} } ) {
    $OUT .= "auto ".$arg->{'name'}." = getValue<input_".$arg->{'name'}."}>; // ".$arg->{'type_name'} ."\n  ";
    push @args, $arg->{'name'};
  } 
  %}

  auto object  = getValue<input_{% $typename %}>; // {% $arduino{'classname'} %}

  {% ($method{'type'} ne 'void') ? 'auto rez = ' : '' %}object->{% $method{'name'} %}( {% join(", ", @args) %} ); // {%
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'void'
  %}
  
  emitValue<output_out>(ctx, {% $method{'type'} ne 'void' ? 'rez' : 1 %}); // {% 
    $method{'type'} ne 'void' 
    ? $method{'type'} 
    : 'pulse. return object instead?' 
  %}
}
EOS

my $gSwitches;

my %commands = (
    # Parts
    library => [ # --- ardlibdir
        ''=>'Make the xod library dir/properties',
        'help|h|H'=>'this',
        ],
    constructor => [ # --- ardlibdir xod-proj-dir # see output of 'library' for xod-proj_dir
        ''=>'Make the constructor nodes',
        '--github-url:s' => 'The github-url for the library (if not in the ard/library.properties',
        'help|h|H'=>'this',
        ],
    methods => [ # --- ardlibdir xod-proj-dir # see output of 'library' for xod-proj_dir
        ''=>'Make the public method nodes',
        'help|h|H'=>'this',
        ],
    # util
    ast => [ # --- ardlibdir
      '' => 'dump the ast',
      'help|h|H'=>'this',
      ],
    unpack => [
        ''=>'Unpack a .xodball into /tmp/xodball/* for further processing',
        'help|h|H'=>'this',
        ],
    );

sub fail_with_help {
    my ($msg, $command) = @_;
    say STDERR $msg;
    @ARGV = qw('--help');
    while(my ($c,$opdef) = each(%commands)) {
        say STDERR $c;
        awgrover::Getopt::xprintSwitchHelp(@$opdef);
        }
    exit 1;
    }

sub ard_dot_h {
  my ($ard) = @_;
  # FIXME: could cache it
  my $fname = basename($ard) . ".h";
  my $path = "$ard/$fname";
  die "Expected the .h '$fname' in $ard" if (!-e $path);
  $path;
  }

sub ard_lib_property {
    # get the value from the .properties
    my ($ard, $property) = @_;
    state %properties;

    $properties{ $ard } ||= do {
        my %p;

        my $ph = IO::File->new($ard . "/library.properties", 'r') or die($!);
        while (<$ph>) {
            my ($key,$value) = /^([^=]+)=(.*)/;
            $p{$key} = $value;
            }
        \%p;
        };

    $properties{ $ard }->{$property};
    }

sub ard_lib_name {
    # from a directory and library_properties.author
    # -> good xod name
    my ($ard) = @_;
    
    # could cache
    my $lib_name = lc( ard_lib_property($ard,'author') . "/" . basename($ard) );
    $lib_name =~ s/_/-/g;
    $lib_name =~ s/[^0-9a-z\/-]//g;
    $lib_name;
    }

sub xodball2tmp {
  # xodball to unpacked tmp dir
  # check for sanity yourself
  my ($xodball) = @_;
  my $leaf = basename($xodball,'.xodball');

  my $path = "/tmp/xodball";
  # FIXME if lib, put in $author/$name
  $path .= "/".$leaf;

  $path;
  }

sub do_unpack {
  # --- $xodprojectdir # > /tmp/
  fail_with_help("Expected a .xodball",'unpack') if !@ARGV;

  foreach my $xod (@ARGV) {

    if (-d $xod || !-e $xod || (basename($xod) !~ /\.xodball$/) ) {
      say STDERR "# Expected a .xodball, but it's not: $xod";
      exit 1;
      }
    
    my $xodtmp = xodball2tmp( $xod );
    say "INTO $xodtmp";
    system('mkdir','-p', $xodtmp) and die;
    say( join " ", ($xodc,'unpack', $xod, $xodtmp."/x"));
    system($xodc,'unpack', $xod, $xodtmp."/x") and die;
    say "# unpacked: $xodtmp";
    }
  }

sub cpp_safe_token {
  my ($a) = @_;
  $a =~ s/-/_/g;
  die "bad token, can't cpp'ize it: '".$_[0]."'" if $a =~ /[^A-Za-z0-9_]/;
  $a
  }

sub foreach_method {
  my ($methods_ast, $block) = @_;
  my $ct = 0;
  say "Method count ".@$methods_ast;
  foreach my $method (@$methods_ast) {
    my $args_ast = find_all(0, $method, \&p_toplevel, p_node_type('PARM_DECL'));
    say "  parms ",dump_shallow($_) foreach @$args_ast;

    my @inputs; # [ $name, $xodtypename, $actual-spelled-type ]
    my @saw; # for error message
    say "  --- args...";
    foreach my $parm (@$args_ast) {
      my $input_name = $parm->{'text'};
      $input_name = cpp_safe_token($input_name);

      my $full_type = $parm->{'type'}; # unparsed, sad. "int *", "bool ()"
      push @saw, "$full_type $input_name";
      my ($base_type, @more_type_pieces) = split(" ",$full_type);

      my $cpp_type = $cpp2xod_type{$base_type};
      if (!$cpp_type) {
        my $sofar = join ", ", @saw;
        die "Don't know type for argument in method ".$method->{'text'}."($sofar,...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }
      my $type_name = $parm->{'type_name'};
      push @inputs, [ $input_name, $cpp_type, $type_name ];
      }

    say "Inputs: ",Dumper(\@inputs);
    say "method ".$method->{'text'}."(",join(", ", map {$_->[0]} @inputs),")";
    &$block( $ct, { name=> $method->{'text'}, type=>$method->{'return_type'}, type_name=>$method->{'type_name'} }, \@inputs );

    $ct += 1;
    }
  }

sub do_ast {
  # just dump the ast
  # --- $ardlib
  my ($ard) = @ARGV;
  my $dot_h = ard_dot_h($ard);
  system("python", "./dump_ast.py", $dot_h);
  exit($?);
  }

sub do_methods {
  # Make public methods patches
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $dot_h = ard_dot_h($ard);
  my $ast = `python ./dump_ast.py "$dot_h"`;
  exit(1) if $?;

  $ast = eval($ast);
  die $@ if $@;
 
  my $class_ast = find_first(0, $ast, \&p_toplevel, p_node_type('CLASS_DECL'));
  die "No class" if !$class_ast;

  my $methods_ast = find_all(0, $class_ast, \&p_toplevel, p_node_type('CXX_METHOD'), p_access('PUBLIC') );
  print "methods ",dump_shallow($_),"\n" foreach @$methods_ast;
  if (!@$methods_ast) {
    warn "No methods";
    return;
    }

  my $cons_patch_name = $class_ast->{'text'} or die("No {'text'} in the class node");
  die "Don't know how to make xod project name safely from '$cons_patch_name'" if $cons_patch_name =~ /[^A-Z0-9a-z_]/;
  my $class_name = $cons_patch_name;
  $cons_patch_name = lc $cons_patch_name; # for xod stuff
  my $cpp_patch_name = $cons_patch_name; # we want _
  $cons_patch_name =~ s/_/-/g; # name wants -

  my $type_base = $xod =~ /\/__lib__\// ? ( basename(dirname($xod)) . "/" . basename($xod) ) : '@';
  my $type_name_output = $type_base . "/output-" . $cpp_patch_name;
  my $type_name_input = $type_base . "/input-" . $cpp_patch_name;
  
  my %method_counts = ();
  my $made_ct = foreach_method($methods_ast, sub {
    my ($ct, $method, $args) = @_;

    # append ct if not first one
    my $this_method_name = $method->{'name'};
    $this_method_name .= $method_counts{$this_method_name} if $method_counts{$this_method_name};

    say "method patch name: $this_method_name";
    say "  #args ",Dumper($args);

    my %xodp; # the .xodp structure for a constructor patch
    $xodp{'description'} = ""; # can we do better?

    # each "row" of a patch
    add_nodes(\%xodp, [$cpp_patch_name => $type_name_input], @$args);
    add_nodes(\%xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);
    if ($method->{'type'}) {
      my $outtype = $cpp2xod_type{ $method->{'type'} };
      $outtype =~ s/\/input-/\/output-/; # 'input' -> 'output'
      if (!$outtype) {
        warn Dumper($method);
        die "Don't know type for return-type of method ".$method->{'type'}." ".$method->{'name'}."(...),\nOnly know: ".join(",", keys %cpp2xod_type) ;
        }
      add_nodes(\%xodp, [ out => $outtype] ); # self creates a type using patch-name
      }
    else {
      add_nodes(\%xodp, [ did => "xod/patch-nodes/output-pulse" ] ); # pulse on finish
      }

    say "Patch ",Dumper(\%xodp);
    write_patch( "$xod/$this_method_name/patch.xodp", \%xodp);
    
    my $namespace = ard_lib_name($ard) . "__" . $cpp_patch_name;
    $namespace =~ s/\//__/g;
    $namespace = cpp_safe_token($namespace);
    
    say "Method ",Dumper($method);
    my %data = (
      arduino => {
        '.h' => basename($dot_h),
        classname => $class_name,
        },
      method => {
        name => $method->{'name'},
        type => ($method->{'type'} eq 'TypeKind.VOID:-2' ? 'void' : $method->{'type_name'}),
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        },
      namespace => $namespace,
      typename => $cpp_patch_name,
      );
    write_patch_cpp("$xod/$this_method_name/patch.cpp", $cpp_method, \%data);

    $ct += 1;
    say "#---end method generation";
    });
  say "Made $made_ct method patches";
  }

sub do_constructor {
  # Make a constructor patch
  # --- $ardlib $xodproject

  my ($ard,$xod) = @ARGV;
  
  # We assume the .h file name
  my $dot_h = ard_dot_h($ard);
  if (!-d $ard || !-e $dot_h) {
    say STDERR "# Expected an arduino library xwith a .h in $ard";
    exit 1;
    }

  if (!-e "$xod/project.xod") {
    say STDERR "# Expected a xod-project-dir with project.xod in $xod";
    exit 1;
    }

  my $ast = `python ./dump_ast.py "$dot_h"`;
  exit(1) if $?;

  $ast = eval($ast);
  die $@ if $@;
 
  my $class_ast = find_first(0, $ast, \&p_toplevel, p_node_type('CLASS_DECL'));
  die "No class" if !$class_ast;
  my $constructor_ast = find_all(0, $class_ast, \&p_toplevel, p_node_type('CONSTRUCTOR') );
  print "cons ",dump_shallow($_),"\n" foreach @$constructor_ast;
  die "No constructors" if !@$constructor_ast;

  my $cons_patch_name = $class_ast->{'text'} or die("No {'text'} in the class node");
  die "Don't know how to make xod project name safely from '$cons_patch_name'" if $cons_patch_name =~ /[^A-Z0-9a-z_]/;
  my $class_name = $cons_patch_name;
  $cons_patch_name = lc $cons_patch_name; # for xod stuff
  my $cpp_patch_name = $cons_patch_name; # we want _
  $cons_patch_name =~ s/_/-/g; # name wants -

  my $type_base = $xod =~ /\/__lib__\// ? ( basename(dirname($xod)) . "/" . basename($xod) ) : '@';
  my $type_name_output = $type_base . "/output-" . $cpp_patch_name;
  my $type_name_input = $type_base . "/input-" . $cpp_patch_name;
  
  my $made_ct = foreach_method($constructor_ast, sub {
    my ($ct, $cons, $args) = @_;

    my $this_constructor_name = $cons_patch_name . ($ct==0 ? '' : $ct); 
    say "Const patch name: $this_constructor_name";

    my %xodp; # the .xodp structure for a constructor patch
    $xodp{'description'} = "constructor"; # can we do better?

    # each "row" of a patch
    add_nodes(\%xodp, @$args);
    add_nodes(\%xodp, [0 => 'xod/patch-nodes/not-implemented-in-xod']);
    if ($ct == 0) {
      add_nodes(\%xodp, [$cons_patch_name => 'xod/patch-nodes/output-self']); # self creates a type using patch-name
      }
    else {
      add_nodes(\%xodp, [$cons_patch_name => $type_name_output] );
      }

    say "Patch ",Dumper(\%xodp);
    write_patch( "$xod/$this_constructor_name/patch.xodp", \%xodp);
    
    my $namespace = ard_lib_name($ard) . "__" . $cpp_patch_name;
    $namespace =~ s/\//__/g;
    $namespace = cpp_safe_token($namespace);

    my $github_url = $gSwitches->{'github-url'} || ard_lib_property($ard,'url');
    die "Tried to get the 'url' from the $ard/library.properties, but it wasn't there, so give me --github-url xxx." if !$github_url;
    warn "The github url was in library.properties: ".ard_lib_property($ard,'url') if $gSwitches->{'github-url'} && ard_lib_property($ard,'url');

    my %data = (
      arduino => {
        github_url => $github_url,
        '.h' => basename($dot_h),
        classname => $class_name,
        },
      constructor => {
        arguments => [
          map { { name => $_->[0], type => $_->[1], type_name => $_->[2] } } @$args # FIXME: use actual type
          ],
        },
      namespace => $namespace,
      typename => $cpp_patch_name,
      );
    say "Data: ",Dumper(\%data);

    write_patch_cpp("$xod/$this_constructor_name/patch.cpp", $cpp_constructor, \%data);
    });
  say "Made $made_ct constructor patches";
  }

sub write_patch_cpp {
  my ($fname, $template_str, $data) = @_;

  my $template = Text::Template->new(
    TYPE => 'STRING', 
    SOURCE => $template_str,
    DELIMITERS => ['{%', '%}']
    );

  say "Data: ",Dumper($data);

  my $cpp = $template->fill_in(HASH => $data);
  my $fh = IO::File->new( $fname, 'w') or die($!);
  print $fh $cpp;
  $fh->close;
  say "Wrote $fname";
  }

sub write_patch {
  my ( $fname, $xodp ) = @_;
  say "make patch $fname...";
  system('mkdir','-p', dirname($fname) ) and die;
  my $xh = IO::File->new( $fname, 'w' ) or die($!);
  print $xh JSON->new->pretty->encode($xodp);
  $xh->close;
  }


sub add_nodes {
  my ($xodp, @inputs) = @_;
  # inputs are a list of [name => type] in order
  # This is one "row" of inputs, arranges these across
  # creates id, position

  #say "Update xodp ",Dumper($xodp);

  $xodp->{'nodes'} ||= [];
  my $nodes = $xodp->{'nodes'};

  my $row_y = (($nodes->[-1] || {})->{'position'} || {})->{'y'};
  $row_y = defined($row_y) ? $row_y + $XODRowSize : $XODRowSize; # start not in corner
  say "Row ",$row_y/$XODRowSize;

  #say "inputs; ",Dumper(\@inputs);
  my $x = 2 * $XODColSize; # start not in corner
  my $in_ct = 0;
  foreach my $nt (@inputs) {
    my ($name,$type) = @$nt;

    my %node;
    $node{'id'} = next_xod_id();
    $node{'label'} = $name if $name; # some nodes have no name, e.g. not-implemented-in-xod
    $node{'type'} = $type;
    $node{'position'} = { x => $x, y => $row_y };

    
    push @$nodes, \%node;

    $x += 2 * $XODColSize;
    $in_ct += 1;
    }
  }

sub next_xod_id {
  # 9 char id
  # start/end with alpha
  state $alpha = ['A'..'Z', 'a'..'z'];
  state $alphanum = [ @$alpha, '0'..'9','-' ];
  $alpha->[ rand( scalar @$alpha ) ] . (join "",map { $alphanum->[ rand( scalar @$alphanum ) ] } (1..7)) . $alpha->[ rand( scalar @$alpha ) ];
  }

sub p_toplevel {
  # if node is toplevel
  my ($depth, $node) =@_;
  $depth == 0;
  }

sub p_access {
  my ($access_type) = @_; # PUBLIC PROTECTED PRIVATE etc.
  sub {
    my ($depth, $node) =@_;
    $node->{'access'} eq $access_type;
    }
  }

sub p_node_type {
  my ($type) = @_;
  sub {
    my ($depth, $node) =@_;
    $node->{'node'} eq $type;
    }
  }

sub dump_shallow {
  my ($node) = @_;
  local $Data::Dumper::Maxdepth=1;
  local $Data::Dumper::Indent=0;
  Dumper($node);
  }

sub find_first {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, 'first', @preds);
  }

sub find_all {
  my ($depth, $ast, @preds) = @_;
  find($depth, $ast, undef, @preds);
  }

sub find {
  # find the first child node for and(....)
  my ($depth, $ast, $onfirst, @preds) = @_;
  #say "start ",dump_shallow($ast) if $depth==0;
  # say "  preds ",join(" ",@preds);

  my @found;
  foreach my $child ( @{ $ast->{'children'} || [] } ) {
    my $hit = 1;
    #say "  child: ",dump_shallow($child);
    foreach my $pred (@preds) {
      if (! &$pred( $depth, $child ) ) {
        $hit = 0;
        last;
        }
      }
    if ($hit) { 
      # say "  HIT ",dump_shallow($child);
      return $child if $onfirst; 
      push @found, $child;
      }
    else {
      # say "Nope $depth";
      }

    find($depth+1, $child, $onfirst, @preds);
    }
  \@found;
 }

sub do_library {
    # make the library bits
    # --- $ardlib # > $xoddir/$author/$arddir

    my $any;
    foreach my $ard (@ARGV) { 
      _do_library($ard);
      $any = 1;
      }
    fail_with_help("# Expected at least 1 arduino library", 'library') if !$any;
    }

sub _do_library {
    my ($ard) = @_;

    if (! -d $ard) {
        say STDERR "# Expected an Arduino library directory, but it's not a directory: $ard";
        exit 1;
        }

    # Dir
    my $subdir = "" . $xoddir;
    $subdir .= "/" . ard_lib_name($ard);
    system('mkdir','-p', $subdir) and die;
    say "made $subdir";

    # project.xod
    my %xod_project = (
        authors => [ grep {$_} (ard_lib_property($ard, 'author'), ard_lib_property($ard, 'maintainer')) ],
        name => ard_lib_property($ard,'name'),
        description => ard_lib_property($ard, 'sentence') . "\n" . ard_lib_property($ard, 'paragraph'),
        version => ard_lib_property($ard,'version'),
        );

    # FIXME: replace keys rather than overwriting all keys
    my $ph = IO::File->new("$subdir/project.xod",'w') or die($!);
    print $ph JSON->new->pretty->encode(\%xod_project);
    say "wrote $subdir/project.xod";

    }

sub main {
    my $command = shift @ARGV;
    fail_with_help( "# Expected a command", undef ) if !defined($command);

    my $whichopts = $commands{$command};
    fail_with_help( "# Expected a command", undef ) if !defined($whichopts);

    $awgrover::Getopt::gUndefIfFail=1;
    $gSwitches = awgrover::Getopt::GetOptions( @$whichopts );
    exit(1) if !$gSwitches;

    no strict 'refs';
    &{"do_".$command}();
    use strict 'refs';
    }

main();
